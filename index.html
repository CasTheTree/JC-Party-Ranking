<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <!-- Lock layout to half-width (960px) by default -->
  <meta name="viewport" content="width=960, initial-scale=1" />
  <title>Song Scoring Dashboard</title>
  <style>
    :root{
      --bg:#0b0b0c; --ink:#e8e8ea; --muted:#a7a7ab; --accent:#7dd3fc; --card:#111114; --ring:#2a2a31;
      --green:#16a34a; --red:#dc2626; --yellow:#facc15;
      --gold:#f5c542; --silver:#c0c0c8; --bronze:#cd7f32;
    }
    html, body { height:100%; }
    html { background:var(--bg); }
    body{
      width:960px; margin:0 auto;
      font:16px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, "Helvetica Neue", Arial, "Apple Color Emoji","Segoe UI Emoji";
      color:var(--ink); display:flex; flex-direction:column; overflow-x:hidden;
      background:var(--bg);
    }
    header{position:sticky; top:0; z-index:10; backdrop-filter:saturate(1.2) blur(6px); background:linear-gradient(180deg, #0b0b0ccc, #0b0b0c80 70%, transparent);}
    .container{max-width:960px; margin:0 auto; padding:20px;}
    h1{font-size:clamp(22px, 2.6vw, 30px); margin:0 0 8px 0}
    .toolbar{display:grid; gap:10px; grid-template-columns: repeat(12,1fr); align-items:end}
    .toolbar .block{grid-column: span 3; min-width:0}
    .toolbar .block.wide{grid-column: span 6}
    label{display:block; font-size:12px; letter-spacing:.02em; color:var(--muted); margin:0 0 4px}
    input, select, button, textarea{
      background:#0f0f12; color:var(--ink); border:1px solid var(--ring); border-radius:10px; padding:10px 12px; width:100%; outline:none;
    }
    textarea{min-height:160px}
    input[type="number"]{appearance:textfield}
    input:focus, select:focus, textarea:focus{border-color:#3b82f6; box-shadow:0 0 0 2px #3b82f640}
    button{cursor:pointer; border:1px solid #2b2b33; background:linear-gradient(180deg,#1b1b20,#121216); font-weight:600}
    button.primary{border-color:#2563eb; background:linear-gradient(180deg,#2563eb,#1d4ed8); color:white}
    button.ghost{background:transparent}
    .row{display:flex; gap:10px}

    /* Mode menu (toggle pills) */
    .mode-menu{display:flex; gap:8px; flex-wrap:wrap}
    .mode-btn{padding:8px 10px; border-radius:999px; border:1px solid var(--ring); background:#0f0f12; font-weight:700}
    .mode-btn.active{outline:2px solid #2563eb; outline-offset:2px}

    /* Roster */
    .roster{margin-top:12px; display:grid; grid-template-columns: 1fr auto auto auto; gap:8px;}
    .roster input{width:100%}

    /* Avatars */
    .avatar{width:24px; height:24px; border-radius:6px; object-fit:cover; border:1px solid var(--ring); background:#0f0f12}
    .avatar.lg{width:28px; height:28px; border-radius:6px}

    /* Form */
    .song-form{margin-top:18px; padding:16px; border:1px dashed var(--ring); border-radius:14px}
    .song-grid{display:grid; gap:10px; grid-template-columns: repeat(12,1fr)}
    .song-grid .span4{grid-column: span 4}
    .song-grid .span12{grid-column: 1 / -1}

    /* Cards grid */
    .cards{display:grid; grid-template-columns: repeat(auto-fill, minmax(260px, 1fr)); gap:16px; margin-top:18px}

    /* Base Card (16:9) */
    .card{
      position:relative; background:var(--card); border:1px solid var(--ring); border-radius:18px; padding:16px;
      aspect-ratio:16/9; display:grid; gap:8px;
    }

    /* Text blocks */
    .title{font-size:18px; font-weight:800; line-height:1.15; white-space:nowrap; overflow:hidden}
    .artist{font-size:14px; color:var(--muted); margin-top:-2px; padding-bottom:8px; white-space:nowrap; overflow:hidden}
    .source{font-size:13px; color:var(--muted); margin-top:-6px; border-bottom:1px dashed var(--ring); padding-bottom:8px; white-space:nowrap; overflow:hidden}

    /* Hero */
    .hero{display:grid; grid-template-columns:auto auto; justify-content:center; align-items:baseline; gap:14px; margin-top:4px;}
    .hero .rank, .hero .avgnum{ font-size:18px; font-weight:800; line-height:1.15; white-space:nowrap; overflow:hidden; }

    /* Score grid */
    .scores{
      display:grid; grid-template-columns: 1fr auto;
      row-gap:8px; column-gap:8px; align-items:center;
      grid-auto-rows: 28px;
    }
    .badge{ display:grid; grid-template-columns: auto 1fr auto; align-items:center; gap:8px; min-width:0; }
    .name{font-size:12px; color:var(--muted); white-space:nowrap; overflow:hidden; text-overflow:ellipsis;}
    .score-cell{ text-align:right; display:flex; align-items:center; justify-content:flex-end; gap:6px; }
    .score{font-variant-numeric:tabular-nums; font-weight:700; display:inline-block; min-width:3.5ch; text-align:right}
    .score.high{color:var(--green)} .score.low{color:var(--red)}
    .score.submitter{ color: var(--yellow); }
    .favStar{ font-weight:900; margin-right:4px; color:var(--yellow); }

    /* Guess pills & pics */
    .guess-pill{
      font-size:11px; padding:0 6px; border-radius:6px; border:1px solid var(--ring); margin-left:6px;
      background:#0f0f12; color:var(--ink);
    }
    .guess-pill.correct{ box-shadow:0 0 0 2px var(--green) inset; }
    .guess-pill.wrong{   box-shadow:0 0 0 2px var(--red) inset; }
    .guess-pic{
      width:18px; height:18px; border-radius:6px; object-fit:cover; border:2px solid var(--ring); margin-left:6px; background:#0f0f12;
    }
    .guess-pic.correct{ border-color: var(--green); }
    .guess-pic.wrong{   border-color: var(--red); }

    /* Favorite toggle in form */
    .fav-toggle{
      width:28px; height:28px; display:inline-flex; align-items:center; justify-content:center;
      border-radius:8px; border:1px solid var(--ring); background:#0f0f12; margin-right:6px;
      font-size:14px; line-height:1; color:#777;
    }
    .fav-toggle[aria-pressed="true"]{ color:var(--yellow); border-color: #caaa1a; }
    .fav-toggle:disabled{ opacity:.5; cursor:not-allowed; }

    .card-actions{display:flex; gap:8px; margin-top:auto}
    .empty{border:1px dashed var(--ring); border-radius:14px; padding:20px; color:var(--muted); text-align:center}

    /* Dialog */
    dialog{border:1px solid var(--ring); border-radius:14px; background:#0f0f12; color:var(--ink); padding:16px; max-width:860px}
    dialog::backdrop{background:rgba(0,0,0,.6)}
    .grid{display:grid; gap:10px; grid-template-columns: repeat(12,1fr)}
    .span6{grid-column: span 6} .span8{grid-column: span 8} .span12{grid-column: 1 / -1}
    .hints{font-size:12px; color:var(--muted)}

    /* Poster layouts (Sidebar only) */
    .poster-grid{position:relative; width:100%; height:100%; display:grid;}
    .panel{ background:transparent; border:none; border-radius:14px; padding:14px; height:100%; overflow:hidden; }
    .card.poster-sidebar{ padding:16px; background:transparent; border-color:transparent; }
    .card.poster-sidebar .poster-grid{ grid-template-columns: 280px 1fr; grid-template-rows: 1fr; column-gap:16px; height:100%; }

    /* ===== People Stats ===== */
    .stats-card{ position:relative; background:var(--card); border:1px solid var(--ring); border-radius:18px; padding:16px; }
    .stats-head{display:flex; align-items:center; justify-content:space-between; gap:12px; margin-top:18px}
    .stats-title{font-weight:800; font-size:18px}
    .stats-wrap{display:grid; grid-template-columns: 1.1fr 1fr; gap:16px; margin-top:12px}
    .stats-chart{ border:1px dashed var(--ring); border-radius:14px; padding:12px; overflow:auto; background:transparent; }
    .stats-table{ border:1px dashed var(--ring); border-radius:14px; overflow:auto; }
    table{width:100%; border-collapse:collapse; font-size:14px}
    th, td{padding:8px 10px; border-bottom:1px solid var(--ring); text-align:left; white-space:nowrap}
    th{font-size:12px; color:var(--muted); position:sticky; top:0; background:linear-gradient(180deg,#101014,#0b0b0c);}
    .pill{font-variant-numeric:tabular-nums; font-weight:800}
    .pill.green{color:var(--green)} .pill.red{color:var(--red)}
    .rank-badge{font-weight:900}
    .chart-row{display:flex; align-items:center; gap:10px; margin:6px 0}
    .chart-name{width:140px; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; font-size:12px; color:var(--muted)}
    .chart-bar-wrap{flex:1; height:22px; border-radius:8px; background:linear-gradient(180deg,#111114,#0f0f12); border:1px solid var(--ring); position:relative}
    .chart-bar{height:100%; border-radius:8px; background:linear-gradient(180deg,#2563eb,#1d4ed8)}
    .chart-val{position:absolute; right:6px; top:0; bottom:0; display:flex; align-items:center; font-variant-numeric:tabular-nums; font-weight:800}
    .export-row{display:flex; gap:8px}
    .chart-bar.best{ background: var(--green) !important; }
    .chart-bar.worst{ background: var(--red) !important; }
    .aff-num{ font-variant-numeric: tabular-nums; font-weight:800 }
    .aff-num.best{ color: var(--green); }
    .aff-num.worst{ color: var(--red); }
    .pill.gold{ color: var(--gold); }
    .stats-table .avatar{ width:22px; height:22px; border-radius:6px; }

	/* Joint Affinity list layout (tightened + right-aligned A + header) */
	.pair-row{
	  display:grid;
	  /* left, arrow, right, A‚ÜíB, B‚ÜíA, joint, bar */
	  grid-template-columns: 150px 20px 150px 56px 56px 56px 2fr;
	  align-items:center;
	  gap:4px;
	  margin:3px 0;
	}

	.pair-left, .pair-right{
	  display:flex; align-items:center; gap:6px;
	  overflow:hidden; white-space:nowrap; text-overflow:ellipsis;
	  font-size:12px; color:var(--muted);
	}

	/* Person A pressed toward the arrow (right edge) */
	.pair-left{ justify-content:flex-end; text-align:right; }
	.pair-left .avatar, .pair-right .avatar{ width:18px; height:18px; flex:0 0 auto; }
	.pair-left span, .pair-right span{ min-width:0; overflow:hidden; text-overflow:ellipsis; }

	.pair-arrow{ text-align:center; font-weight:800; }

	.pair-num{
	  text-align:right;
	  font-variant-numeric:tabular-nums;
	  font-weight:800;
	  padding:0 2px; /* denser number columns */
	}

	/* Header styling */
	.pair-header{
	  font-size:11px; color:var(--muted);
	  border-bottom:1px dashed var(--ring);
	  padding-bottom:4px; margin-bottom:6px;
	}
	.pair-bar-label{ text-align:right; font-weight:700; }


    @media (max-width:980px){ .stats-wrap{grid-template-columns:1fr} }
    @media (max-width:840px){
      .toolbar .block{grid-column: span 6}
      .toolbar .block.wide{grid-column: 1 / -1}
      .song-grid .span4{grid-column: span 6}
      .span6{grid-column: 1 / -1}
      .span8{grid-column: 1 / -1}
    }
  </style>
</head>
<body>
  <header>
    <div class="container">
      <h1>üéµ Song Scoring Dashboard</h1>
      <div class="toolbar" role="region" aria-label="Controls">
        <div class="block">
          <label for="peopleCount">Number of people</label>
          <input id="peopleCount" type="number" min="1" value="3" />
        </div>
        <div class="block wide">
          <label>People (names)</label>
          <div id="roster" class="roster" aria-live="polite"></div>
        </div>

        <!-- Mode toggles -->
        <div class="block">
          <label>Modes</label>
          <div id="modeMenu" class="mode-menu" role="group" aria-label="Modes">
            <button type="button" class="mode-btn" data-flag="anime">Anime</button>
            <button type="button" class="mode-btn" data-flag="game">Game</button>
            <button type="button" class="mode-btn" data-flag="anonymous">Anonymous</button>
          </div>
        </div>

        <!-- Layout: Sidebar Left only -->
        <div class="block">
          <label for="layoutStyle">Layout</label>
          <select id="layoutStyle" disabled>
            <option value="poster-sidebar" selected>Poster: Sidebar Left</option>
          </select>
        </div>

        <div class="block">
          <label for="sortBy">Sort by</label>
          <select id="sortBy">
            <option value="avg_desc">Ranking (High ‚Üí Low)</option>
            <option value="avg_asc">Average (Low ‚Üí High)</option>
            <option value="title_asc">Title (A ‚Üí Z)</option>
            <option value="artist_asc">Artist (A ‚Üí Z)</option>
			<option value="submitter_asc">Submitter (A ‚Üí Z)</option>
          </select>
        </div>

        <!-- Guess display toggle -->
        <div class="block">
          <label for="guessDisplay">Guess display</label>
          <select id="guessDisplay">
            <option value="names" selected>Names</option>
            <option value="pictures">Pictures</option>
          </select>
        </div>

        <div class="block">
          <label>&nbsp;</label>
          <button id="exportAll" title="Export all cards as transparent PNGs">Export All PNGs</button>
        </div>

        <div class="block">
          <label>&nbsp;</label>
          <button id="openBulk" class="primary" title="Paste from Google Slides/Sheets">Bulk add (scores)</button>
        </div>
        <div class="block">
          <label>&nbsp;</label>
          <button id="openBulkGuesses" title="Paste anonymous guesses CSV/TSV">Bulk add (guesses)</button>
        </div>
      </div>

      <form id="songForm" class="song-form" autocomplete="off">
        <div class="song-grid">
          <div class="span4">
            <label for="title">Song title</label>
            <input id="title" required placeholder="e.g., This Song" />
          </div>
          <div class="span4">
            <label for="artist">Artist</label>
            <input id="artist" required placeholder="e.g., Music Man" />
          </div>
          <div class="span4">
            <label for="submitter">Submitter</label>
            <input id="submitter" required placeholder="Pick from roster or type" list="rosterList" />
            <datalist id="rosterList"></datalist>
          </div>

          <!-- Source field (Anime/Game/Source) -->
          <div class="span4" id="sourceFieldWrap" style="display:none">
            <label id="sourceLabel" for="sourceInput">Source</label>
            <input id="sourceInput" placeholder="" />
          </div>

          <div class="span12">
            <label id="scoresLabel">Scores (per person)</label>
            <div id="scoreInputs" class="row" style="flex-wrap:wrap"></div>
          </div>
          <div class="span4">
            <label for="avgOverride">Average (optional ‚Äî you can paste yours)</label>
            <input id="avgOverride" type="number" step="0.01" placeholder="Leave blank to auto-calc" />
          </div>
          <div class="span4">
            <label>&nbsp;</label>
            <button class="primary" type="submit">Add song</button>
          </div>
          <div class="span4">
            <label>&nbsp;</label>
            <button type="button" id="clearForm" class="ghost">Clear</button>
          </div>
        </div>
      </form>
    </div>
  </header>

  <main class="container" style="padding-top:6px; padding-bottom:40px">
    <!-- ===== People ‚Äî Chart ===== -->
    <section id="peopleChart" class="stats-card" aria-live="polite">
      <div class="stats-head">
        <div class="stats-title">üìà People ‚Äî Avg (received) chart</div>
        <div class="export-row">
          <label for="statsColor" class="name" style="align-self:center">Graph color</label>
          <select id="statsColor" style="width:auto">
            <option value="blue" selected>Blue</option>
            <option value="green">Green</option>
            <option value="red">Red</option>
            <option value="purple">Purple</option>
            <option value="pink">Pink</option>
            <option value="gold">Gold</option>
            <option value="gray">Gray</option>
          </select>
          <button id="exportStatsChart" title="Export chart as transparent PNG">Export Chart PNG</button>
        </div>
      </div>
      <div class="stats-chart" id="statsChart" aria-label="Ranking chart (higher is better)"></div>
    </section>

    <!-- ===== People ‚Äî Table ===== -->
    <section id="peopleStats" class="stats-card" aria-live="polite">
      <div class="stats-head">
        <div class="stats-title">üë§ People ‚Äî Stats table</div>
        <div class="export-row">
          <button id="openComments" data-hide-on-export title="Manually set per-person comment counts">üó£Ô∏è Edit comments</button>
          <button id="exportStatsPanel" title="Export table as transparent PNG">Export Table PNG</button>
        </div>
      </div>
      <div class="stats-table" id="statsTable" aria-label="Per-person details"></div>
    </section>

    <!-- ===== Affinity ===== -->
    <section id="affinitySection" class="stats-card" aria-live="polite">
      <div class="stats-head">
        <div class="stats-title">ü§ù Affinity ‚Äî who likes whose songs</div>
        <div class="export-row">
          <button id="exportAffinity" title="Export as transparent PNG">Export Affinity PNG</button>
        </div>
      </div>
      <div class="stats-table" id="affinityTable"></div>
    </section>

    <!-- ===== Joint Affinity (LIST) ===== -->
    <section id="jointAffinitySection" class="stats-card" aria-live="polite">
		<div class="stats-head">
		  <div class="stats-title">üîó Joint Affinity ‚Äî top pairs (A‚ÜîB)</div>
		  <div class="export-row">
			<label for="jointColor" class="name" style="align-self:center">Graph color</label>
			<select id="jointColor" style="width:auto">
			  <option value="blue" selected>Blue</option>
			  <option value="green">Green</option>
			  <option value="red">Red</option>
			  <option value="purple">Purple</option>
			  <option value="pink">Pink</option>
			  <option value="gold">Gold</option>
			  <option value="gray">Gray</option>
			</select>
			<button id="exportJointAffinity" type="button" title="Export as transparent PNG">Export Joint Affinity PNG</button>
		  </div>
		</div>
      <div class="stats-chart" id="jointAffinityList"></div>
    </section>

    <section id="cards" class="cards" aria-live="polite" style="margin-top:18px">
      <div class="empty" id="emptyState">No songs yet ‚Äî add one above ‚ú®</div>
    </section>
  </main>

  <!-- Bulk import (scores) -->
  <dialog id="bulkDialog">
    <form method="dialog" id="bulkForm">
      <h2 style="margin:0 0 8px">Bulk add songs ‚Äî scores</h2>
      <p class="hints">Paste rows from Google <b>Slides</b> (table) or <b>Sheets</b>. Required headers: <code>song</code>, <code>artist</code>, <code>submitter|nominator</code>. Optional: <code>anime|game</code> source, <code>average</code>. Headers matching roster names are treated as that person's score.</p>
      <p class="hints"><b>Tip:</b> add an asterisk directly after a score to mark that voter as favoriting the song, e.g., <code>8*</code> or <code>7.9*</code>.</p>
      <div class="grid">
        <div class="span12">
          <label for="bulkText">Rows (CSV/TSV)</label>
          <textarea id="bulkText" placeholder="Nominator,Song,Artist,Game/Anime,Average,Nick,Jiho,...&#10;Nick,Martyr,Monster Siren Records,Arknights,6.9,/,8*,7,..."></textarea>
        </div>
        <div class="span6">
          <label for="hasHeader">First row is header</label>
          <select id="hasHeader">
            <option value="yes" selected>Yes</option>
            <option value="no">No</option>
          </select>
        </div>
        <div class="span6">
          <label for="delimiter">Delimiter</label>
          <select id="delimiter">
            <option value="auto" selected>Auto-detect</option>
            <option value=",">Comma</option>
            <option value="\t">Tab</option>
            <option value=";">Semicolon</option>
          </select>
        </div>
        <div class="span12">
          <div class="row" style="justify-content:flex-end; gap:8px">
            <button value="cancel" type="button" id="cancelBulk" class="ghost">Cancel</button>
            <button value="default" type="submit" class="primary">Import rows</button>
          </div>
        </div>
      </div>
      <details class="hints" style="margin-top:8px">
        <summary>Header examples</summary>
        <code>Submitter,Song,Artist,Anime,Average,Nick,Jiho,Nathan,...</code><br/>
        <code>Nominator,Song,Artist,Game,Average,Nick,Jiho,Zarif,...</code>
      </details>
    </form>
  </dialog>

  <!-- Bulk import (guesses) -->
  <dialog id="bulkGuessDialog">
    <form method="dialog" id="bulkGuessForm">
      <h2 style="margin:0 0 8px">Bulk add guesses ‚Äî anonymous</h2>
      <p class="hints">Format example:<br>
        <code>Nominator,Song,Artist,Roanyk,Jiho,Nathan,Desmond,Jaheim,Caelan,Jeff,Waj,Asif</code><br>
        <code>Desmond,Slider,Koji Kondo,Desmond,Desmond,Desmond,/,Roanyk,Desmond,Desmond,Asif,Desmond</code>
      </p>
      <div class="grid">
        <div class="span12">
          <label for="bulkGuessText">Rows (CSV/TSV)</label>
          <textarea id="bulkGuessText" placeholder="Paste guesses sheet rows here..."></textarea>
        </div>
        <div class="span6">
          <label for="guessHasHeader">First row is header</label>
          <select id="guessHasHeader">
            <option value="yes" selected>Yes</option>
            <option value="no">No</option>
          </select>
        </div>
        <div class="span6">
          <label for="guessDelimiter">Delimiter</label>
          <select id="guessDelimiter">
            <option value="auto" selected>Auto-detect</option>
            <option value=",">Comma</option>
            <option value="\t">Tab</option>
            <option value=";">Semicolon</option>
          </select>
        </div>
        <div class="span12">
          <div class="row" style="justify-content:flex-end; gap:8px">
            <button value="cancel" type="button" id="cancelBulkGuess" class="ghost">Cancel</button>
            <button value="default" type="submit" class="primary">Import guesses</button>
          </div>
        </div>
      </div>
    </form>
  </dialog>

  <!-- Comments editor dialog -->
  <dialog id="commentsDialog">
    <form method="dialog" id="commentsForm">
      <h2 style="margin:0 0 8px">üó£Ô∏è Comments per person</h2>
      <p class="hints">Enter a manual count for each person (integers). These appear in the People Stats table.</p>
      <div id="commentsList" class="grid" style="grid-template-columns: 1fr auto; row-gap:8px; column-gap:12px"></div>
      <div class="row" style="justify-content:flex-end; gap:8px; margin-top:12px">
        <button value="cancel" type="button" id="cancelComments" class="ghost">Cancel</button>
        <button value="default" type="submit" class="primary">Save</button>
      </div>
    </form>
  </dialog>

  <!-- html2canvas for export -->
  <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
  <script>
    /* ========== Element refs ========== */
    const peopleCountEl = document.getElementById('peopleCount');
    const rosterEl = document.getElementById('roster');
    const datalistEl = document.getElementById('rosterList');
    const scoreInputsEl = document.getElementById('scoreInputs');
    const songForm = document.getElementById('songForm');
    const cardsEl = document.getElementById('cards');
    const sortByEl = document.getElementById('sortBy');
    const exportAllBtn = document.getElementById('exportAll');
    const submitterEl = document.getElementById('submitter');
    const titleEl = document.getElementById('title');
    const artistEl = document.getElementById('artist');

    // Modes / source / labels
    const modeMenuEl = document.getElementById('modeMenu');
    const sourceFieldWrap = document.getElementById('sourceFieldWrap');
    const sourceLabelEl = document.getElementById('sourceLabel');
    const sourceInputEl = document.getElementById('sourceInput');
    const scoresLabelEl = document.getElementById('scoresLabel');

    // Guess display
    const guessDisplayEl = document.getElementById('guessDisplay');
    let guessDisplayMode = guessDisplayEl?.value || 'names';
    guessDisplayEl?.addEventListener('change', () => { guessDisplayMode = guessDisplayEl.value; refreshAllCards(); });

    // Stats panels
    const statsChartEl = document.getElementById('statsChart');
    const statsTableEl = document.getElementById('statsTable');
    const exportStatsChartBtn = document.getElementById('exportStatsChart');
    const exportStatsPanelBtn = document.getElementById('exportStatsPanel');
    const statsColorEl = document.getElementById('statsColor');
    let statsColor = statsColorEl?.value || 'blue';
// Re-enable live color changes for the Avg (received) chart
statsColorEl?.addEventListener('change', () => {
  statsColor = statsColorEl.value;
  renderPeopleChart();
});

    // Affinity
    const affinitySectionEl = document.getElementById('affinitySection');
    const affinityTableEl = document.getElementById('affinityTable');
    const exportAffinityBtn = document.getElementById('exportAffinity');

    // Joint Affinity
    const jointAffinitySectionEl = document.getElementById('jointAffinitySection');
    const jointAffinityListEl = document.getElementById('jointAffinityList');
    const exportJointAffinityBtn = document.getElementById('exportJointAffinity');
	const jointColorEl = document.getElementById('jointColor');
	let jointColor = jointColorEl?.value || 'blue';
	jointColorEl?.addEventListener('change', () => {
	  jointColor = jointColorEl.value;
	  renderJointAffinity();
	});

    // Comments editor
    const openCommentsBtn = document.getElementById('openComments');
    const commentsDialog  = document.getElementById('commentsDialog');
    const commentsForm    = document.getElementById('commentsForm');
    const commentsListEl  = document.getElementById('commentsList');

    // Bulk dialogs
    const bulkDialog = document.getElementById('bulkDialog');
    const openBulkBtn = document.getElementById('openBulk');
    const bulkForm = document.getElementById('bulkForm');
    const bulkText = document.getElementById('bulkText');
    const hasHeaderEl = document.getElementById('hasHeader');
    const delimiterEl = document.getElementById('delimiter');
    const cancelBulkBtn = document.getElementById('cancelBulk');

    const bulkGuessDialog = document.getElementById('bulkGuessDialog');
    const openBulkGuessesBtn = document.getElementById('openBulkGuesses');
    const bulkGuessForm = document.getElementById('bulkGuessForm');
    const bulkGuessText = document.getElementById('bulkGuessText');
    const guessHasHeaderEl = document.getElementById('guessHasHeader');
    const guessDelimiterEl = document.getElementById('guessDelimiter');
    const cancelBulkGuessBtn = document.getElementById('cancelBulkGuess');

    /* ========== State ========== */
    let roster = ['Person 1','Person 2','Person 3'];
    let photos = {}; // { [name]: dataUrl }
    // song: {id,title,artist,submitter,avg,scores:{},favorites:{},flags:{anime,game,anonymous},sourceText?:string,guesses?:{[voter]:string}}
    let songs = [];
    let commentCounts = {}; // { [name]: number }
    let ranksMap = new Map();
    let tieBreakers = new Map();

    /* ========== Utils ========== */
    const EPS = 1e-6;
    const uid = () => Math.random().toString(36).slice(2,9);
    const clamp = (n, min, max) => Math.min(Math.max(n, min), max);
    const sanitizeFilename = (s) => s.replace(/[\/:*?"<>|]/g,'_').slice(0,80);
    const readImageAsDataURL = (file) => new Promise((resolve,reject)=>{ const fr=new FileReader(); fr.onload=()=>resolve(fr.result); fr.onerror=reject; fr.readAsDataURL(file); });
    function norm(s){return (s||'').toString().trim();}
    function lc(s){return norm(s).toLowerCase();}
    const RESERVED_HEADERS = new Set(['song','title','artist','submitter','nominator','average','anime','game']);
    function isBlankScore(v){ const t = lc(v); return t===''||t==='/'||t==='na'||t==='n/a'||t==='‚Äì'||t==='‚Äî'||t==='nil'; }
    function parseScoreCell(raw){ const txt=(raw||'').toString().trim(); const favorite=/[*‚òÖ]/.test(txt); const num=parseFloat(txt.replace(/[^\d.]+/g,'')); return { num: Number.isFinite(num)? num : NaN, favorite }; }

    /* Resize helpers (single definition) */
    function shrinkToFit(el, minPx=10){
      const style = getComputedStyle(el);
      const base = parseFloat(style.fontSize) || 18;
      el.style.fontSize = base + 'px';
      let guard = 0;
      while (el.scrollWidth > el.clientWidth && guard < 60) {
        const cur = parseFloat(getComputedStyle(el).fontSize);
        if (cur <= minPx) break;
        el.style.fontSize = (cur - 0.5) + 'px';
        guard++;
      }
    }
    const resizeObserver = new ResizeObserver(() => {
      document.querySelectorAll('.title, .artist, .source, .hero .rank, .hero .avgnum').forEach(shrinkToFit);
    });
    window.addEventListener('resize', () => {
      document.querySelectorAll('.title, .artist, .source, .hero .rank, .hero .avgnum').forEach(shrinkToFit);
      renderPeopleChart(); renderPeopleStatsTable(); renderAffinity(); renderJointAffinity();
    });

    function ensureCommentKeys(){ roster.forEach(name=>{ if(!commentCounts.hasOwnProperty(name)) commentCounts[name] = 0; }); }

    /* ========== Modes ========== */
    const activeFlags = ()=> {
      const flags = {anime:false, game:false, anonymous:false};
      modeMenuEl.querySelectorAll('.mode-btn').forEach(btn=>{
        if(btn.classList.contains('active')) flags[btn.dataset.flag] = true;
      });
      return flags;
    };
    function songHasFlag(song, flag){
      if(song?.flags && typeof song.flags[flag] === 'boolean') return !!song.flags[flag];
      return !!activeFlags()[flag];
    }

    modeMenuEl.addEventListener('click', (e)=>{
      const btn = e.target.closest('.mode-btn'); if(!btn) return;
      btn.classList.toggle('active');
      updateSourceFieldVisibility();
      rebuildScoreInputs();
      refreshAllCards();
    });

    function updateSourceFieldVisibility(){
      const flags = activeFlags();
      const showSrc = flags.anime || flags.game;
      sourceFieldWrap.style.display = showSrc ? '' : 'none';
      if(flags.anime && flags.game){
        sourceLabelEl.textContent = 'Source';
        sourceInputEl.placeholder = 'Anime or Game';
      } else if(flags.anime){
        sourceLabelEl.textContent = 'Anime';
        sourceInputEl.placeholder = 'e.g., ACCA: 13-Territory Inspection Dept.';
      } else if(flags.game){
        sourceLabelEl.textContent = 'Game';
        sourceInputEl.placeholder = 'e.g., Arknights';
      } else {
        sourceInputEl.value = '';
      }
      scoresLabelEl.textContent = flags.anonymous ? 'Scores (per person) ‚Ä¢ plus each person\'s guess' : 'Scores (per person)';
    }

    /* ========== Roster UI ========== */
    function personAvatarEl(name, size='sm'){
      const img = document.createElement('img');
      img.className = size==='lg' ? 'avatar lg' : 'avatar';
      img.alt = name ? `${name}'s avatar` : 'avatar';
      if(photos[name]) img.src = photos[name];
      else { img.style.background = '#0f0f12'; img.style.border = '1px solid var(--ring)'; }
      return img;
    }

    function renderRosterInputs(){
      rosterEl.innerHTML = '';
      datalistEl.innerHTML = '';
      roster.forEach((name, i)=>{
        const rowName = document.createElement('input');
        rowName.value = name;
        rowName.placeholder = `Person ${i+1}`;
        rowName.addEventListener('change', ()=>{
          const oldName = roster[i];
          const newName = rowName.value.trim();
          if(photos[oldName] && !photos[newName]) photos[newName] = photos[oldName];
          if(commentCounts.hasOwnProperty(oldName) && !commentCounts.hasOwnProperty(newName)) commentCounts[newName] = commentCounts[oldName];
          if(oldName !== newName){ delete photos[oldName]; delete commentCounts[oldName]; }
          roster[i] = newName;
          rebuildScoreInputs(); fillDatalist(); refreshAllCards(); renderRosterInputs(); renderPeopleChart(); renderPeopleStatsTable(); renderAffinity(); renderJointAffinity();
        });

        const uploadBtn = document.createElement('input');
        uploadBtn.type = 'file'; uploadBtn.accept = 'image/*'; uploadBtn.title='Upload avatar'; uploadBtn.style.width='42px';
        uploadBtn.addEventListener('change', async ()=>{
          const file = uploadBtn.files?.[0]; if(!file) return;
          const dataUrl = await readImageAsDataURL(file);
          photos[roster[i]] = dataUrl; refreshAllCards(); renderRosterInputs(); rebuildScoreInputs(); renderPeopleChart(); renderPeopleStatsTable(); renderAffinity(); renderJointAffinity();
        });

        const clearBtn = document.createElement('button'); clearBtn.textContent='üóë'; clearBtn.type='button'; clearBtn.title='Remove avatar'; clearBtn.style.width='42px';
        clearBtn.addEventListener('click', ()=>{ delete photos[roster[i]]; refreshAllCards(); renderRosterInputs(); rebuildScoreInputs(); renderPeopleChart(); renderPeopleStatsTable(); renderAffinity(); renderJointAffinity(); });

        const removeBtn = document.createElement('button'); removeBtn.textContent='‚úï'; removeBtn.type='button'; removeBtn.title='Remove person'; removeBtn.style.width='42px';
        removeBtn.addEventListener('click', ()=>{
          delete photos[roster[i]];
          roster.splice(i,1);
          peopleCountEl.value = roster.length;
          Object.keys(commentCounts).forEach(k=>{ if(!roster.includes(k)) delete commentCounts[k]; });
          renderRosterInputs(); rebuildScoreInputs(); fillDatalist(); refreshAllCards(); renderPeopleChart(); renderPeopleStatsTable(); renderAffinity(); renderJointAffinity();
        });

        const preview = personAvatarEl(name, 'lg');

        const nameWrap = document.createElement('div');
        nameWrap.style.display='flex'; nameWrap.style.alignItems='center'; nameWrap.style.gap='8px';
        nameWrap.appendChild(preview); nameWrap.appendChild(rowName);

        rosterEl.appendChild(nameWrap);
        rosterEl.appendChild(uploadBtn);
        rosterEl.appendChild(clearBtn);
        rosterEl.appendChild(removeBtn);

        const opt = document.createElement('option'); opt.value = name; datalistEl.appendChild(opt);
      });
    }
    function fillDatalist(){ datalistEl.innerHTML = ''; roster.forEach(n=>{ const o=document.createElement('option'); o.value=n; datalistEl.appendChild(o);}); }

    peopleCountEl.addEventListener('change', ()=>{
      const n = clamp(parseInt(peopleCountEl.value||'0',10),1,50);
      const diff = n - roster.length;
      if(diff>0){ for(let i=0;i<diff;i++){ roster.push(`Person ${roster.length+1}`);} }
      if(diff<0){
        const removed = roster.slice(n);
        removed.forEach(name => { delete photos[name]; delete commentCounts[name]; });
        roster.splice(n);
      }
      renderRosterInputs(); rebuildScoreInputs(); fillDatalist(); refreshAllCards(); renderPeopleChart(); renderPeopleStatsTable(); renderAffinity(); renderJointAffinity();
    });

    /* ========== Inputs (scores + guesses + manual favorites) ========== */
    submitterEl.addEventListener('input', rebuildScoreInputs);
    function rebuildScoreInputs(){
      scoreInputsEl.innerHTML = '';
      const sub = lc((submitterEl.value || '').trim());
      const flags = activeFlags();
      roster.forEach((name, idx)=>{
        const wrap = document.createElement('div');
        wrap.style.minWidth='260px'; wrap.style.flex='1 1 260px';

        const who = name || `Person ${idx+1}`;

        const img = personAvatarEl(who);
        const txt = document.createElement('span'); txt.className='name'; txt.textContent = who;

        const left = document.createElement('div');
        left.className='badge';
        left.appendChild(img);
        left.appendChild(txt);

        const row = document.createElement('div');
        row.style.display='grid';
        row.style.gridTemplateColumns='1fr 220px';
        row.style.alignItems='center';
        row.style.gap='8px';

        const scoreWrap = document.createElement('div'); scoreWrap.className='score-cell';

        // Manual favorite toggle
        const favBtn = document.createElement('button');
        favBtn.type='button'; favBtn.className='fav-toggle'; favBtn.innerHTML='‚òÖ'; favBtn.dataset.person = who;
        favBtn.title = 'Toggle favorite';
        if(lc(who)===sub){ favBtn.disabled = true; favBtn.title = 'Submitter cannot favorite their own song'; }
        favBtn.setAttribute('aria-pressed','false');
        favBtn.addEventListener('click', ()=>{
          if(favBtn.disabled) return;
          const on = favBtn.getAttribute('aria-pressed') === 'true';
          favBtn.setAttribute('aria-pressed', String(!on));
        });
        scoreWrap.appendChild(favBtn);

        const inp = document.createElement('input');
        inp.type='number'; inp.step='0.01'; inp.placeholder='score'; inp.dataset.person = who;
        if(lc(who)===sub){ inp.disabled = true; inp.title = 'Submitter cannot score their own song'; }
        scoreWrap.appendChild(inp);

        // Anonymous mode: add a guess select for each person
        if(flags.anonymous){
          const guessSel = document.createElement('select');
          guessSel.dataset.person = who;
          guessSel.className = 'guess-input';
          guessSel.title = 'Guess who submitted this';
          const placeholder = document.createElement('option');
          placeholder.value = ''; placeholder.textContent = '‚Äî Guess submitter ‚Äî';
          guessSel.appendChild(placeholder);
          roster.forEach(optName=>{
            const opt = document.createElement('option');
            opt.value = optName; opt.textContent = optName;
            guessSel.appendChild(opt);
          });
          guessSel.style.minWidth = '160px';
          scoreWrap.appendChild(guessSel);
        }

        row.appendChild(left);
        row.appendChild(scoreWrap);
        wrap.appendChild(row);
        scoreInputsEl.appendChild(wrap);
      });
    }

    /* ========== Averages / sorting ========== */
    function computeAverage(scores){
      const vals = Object.values(scores).map(v=> typeof v==="number"? v : parseFloat(v)).filter(v=>!Number.isNaN(v));
      if(!vals.length) return 0;
      return vals.reduce((a,b)=>a+b,0)/vals.length;
    }
    function refreshTieBreakers(){ tieBreakers = new Map(songs.map(s => [s.id, Math.random()])); }
    function sortByRanking(a,b){
      const diff = (b.avg) - (a.avg);
      if (Math.abs(diff) > EPS) return diff;
      return (tieBreakers.get(a.id) ?? 0) - (tieBreakers.get(b.id) ?? 0);
    }
    function shuffle(arr){ for (let i = arr.length - 1; i > 0; i--){ const j = Math.floor(Math.random() * (i + 1)); [arr[i], arr[j]] = [arr[j], arr[i]]; } return arr; }
    function assignRanks(){
      const sorted = [...songs].sort((a,b)=> (b.avg)-(a.avg));
      const eps = 1e-6, groups = []; let cur = [];
      for (const s of sorted){
        if (!cur.length || Math.abs(s.avg - cur[0].avg) <= eps) cur.push(s);
        else { groups.push(cur); cur = [s]; }
      }
      if (cur.length) groups.push(cur);
      const ordered = []; for (const g of groups){ shuffle(g); ordered.push(...g); }
      ranksMap = new Map(); ordered.forEach((s, idx)=>{ ranksMap.set(s.id, idx + 1); }); songs = ordered;
    }
	// Compute rank numbers by average ONLY (does NOT reorder `songs`)
	function computeRanksOnly(){
	  const eps = 1e-6;
	  const sorted = [...songs].sort((a,b)=> (b.avg) - (a.avg));
	  const groups = [];
	  let cur = [];
	  for (const s of sorted){
		if (!cur.length || Math.abs(s.avg - cur[0].avg) <= eps) cur.push(s);
		else { groups.push(cur); cur = [s]; }
	  }
	  if (cur.length) groups.push(cur);
	  const ordered = [];
	  for (const g of groups){ shuffle(g); ordered.push(...g); } // tie shuffle like before
	  ranksMap = new Map();
	  ordered.forEach((s, idx)=>{ ranksMap.set(s.id, idx + 1); });
	}

	// Apply the currently selected sort from the dropdown (preserves selection)
	function applyCurrentSort(){
	  const val = sortByEl?.value || 'avg_desc';
	  refreshTieBreakers();

	  const byTitle   = (a,b)=> (a.title||'').localeCompare(b.title||'',   undefined, {sensitivity:'base'});
	  const byArtist  = (a,b)=> (a.artist||'').localeCompare(b.artist||'', undefined, {sensitivity:'base'});
	  const bySubmit  = (a,b)=> (a.submitter||'').localeCompare(b.submitter||'', undefined, {sensitivity:'base'});
	  const byAvgAsc  = (a,b)=> (a.avg) - (b.avg);

	  if (val === 'avg_desc') {
		songs.sort(sortByRanking);
	  } else {
		const cmp =
		  val === 'avg_asc'       ? byAvgAsc :
		  val === 'title_asc'     ? byTitle  :
		  val === 'artist_asc'    ? byArtist :
		  val === 'submitter_asc' ? bySubmit :
		  sortByRanking; // fallback

		songs.sort((a,b)=>{
		  const diff = cmp(a,b);
		  if (diff !== 0 && !Number.isNaN(diff)) return diff;
		  return (tieBreakers.get(a.id) ?? 0) - (tieBreakers.get(b.id) ?? 0);
		});
	  }

	  // Always recompute ranks by avg, but do NOT reorder the songs here
	  computeRanksOnly();
	}
    function placeText(n){
      const s = String(n);
      if(s.endsWith('11') || s.endsWith('12') || s.endsWith('13')) return `${n}th`;
      if(s.endsWith('1')) return `${n}st`;
      if(s.endsWith('2')) return `${n}nd`;
      if(s.endsWith('3')) return `${n}rd`;
      return `${n}th`;
    }
    function placementColor(rank){
      if(rank===1) return getComputedStyle(document.documentElement).getPropertyValue('--gold').trim() || '#f5c542';
      if(rank===2) return getComputedStyle(document.documentElement).getPropertyValue('--silver').trim() || '#c0c0c8';
      if(rank===3) return getComputedStyle(document.documentElement).getPropertyValue('--bronze').trim() || '#cd7f32';
      return getComputedStyle(document.documentElement).getPropertyValue('--ink').trim() || '#e8e8ea';
    }
    function chartGradient(color){
      switch(color){
        case 'green':  return 'linear-gradient(180deg,#16a34a,#15803d)';
        case 'red':    return 'linear-gradient(180deg,#dc2626,#b91c1c)';
        case 'purple': return 'linear-gradient(180deg,#8b5cf6,#7c3aed)';
        case 'pink':   return 'linear-gradient(180deg,#ec4899,#db2777)';
        case 'gold':   return `linear-gradient(180deg,${getComputedStyle(document.documentElement).getPropertyValue('--gold').trim()||'#f5c542'},#d4a72c)`;
        case 'gray':   return 'linear-gradient(180deg,#6b7280,#4b5563)';
        default:       return 'linear-gradient(180deg,#2563eb,#1d4ed8)';
      }
    }

    /* ========== Cards ========== */
    function getExtrema(scores){
      const entries = Object.entries(scores).filter(([,v])=>v!=='' && v!=null && !Number.isNaN(parseFloat(v)));
      if(entries.length===0) return {maxNames:new Set(), minNames:new Set()};
      const nums = entries.map(([n,v])=>[n, parseFloat(v)]);
      const maxVal = Math.max(...nums.map(([,v])=>v));
      const minVal = Math.min(...nums.map(([,v])=>v));
      const maxNames = new Set(nums.filter(([,v])=>v===maxVal).map(([n])=>n));
      const minNames = new Set(nums.filter(([,v])=>v===minVal).map(([n])=>n));
      return {maxNames, minNames};
    }

    function buildScoresList(names, song, extraClass=''){
      const {maxNames, minNames} = getExtrema(song.scores);
      const wrap = document.createElement('div');
      wrap.className = `scores ${extraClass}`.trim();

      names.forEach(person=>{
        const rowL = document.createElement('div');
        const badge = document.createElement('div'); badge.className='badge';
        const img = personAvatarEl(person);
        const nameSpan = document.createElement('span'); nameSpan.className='name'; nameSpan.textContent = person;
        badge.appendChild(img); badge.appendChild(nameSpan);

        // Anonymous: show guessed identity with correctness border
        if(songHasFlag(song,'anonymous')){
          const g = (song.guesses||{})[person];
          if(g){
            const correct = lc(g) === lc(song.submitter);
            if(guessDisplayMode === 'pictures'){
              const gImg = personAvatarEl(g);
              gImg.classList.add('guess-pic');
              gImg.classList.add(correct ? 'correct' : 'wrong');
              badge.appendChild(gImg);
            } else {
              const pill = document.createElement('span'); pill.className='guess-pill'; pill.textContent = g;
              pill.classList.add(correct ? 'correct' : 'wrong');
              badge.appendChild(pill);
            }
          }
        }
        rowL.appendChild(badge);

        const rowR = document.createElement('div'); rowR.className='score-cell';

        // Favorite star
        const isFav = !!(song.favorites && song.favorites[person]);
        if(isFav){ const star=document.createElement('span'); star.className='favStar'; star.textContent='‚òÖ'; rowR.appendChild(star); }

        const sv = document.createElement('span'); sv.className='score';
        const isSubmitter = (person && song.submitter && lc(person)===lc(song.submitter));
        if(isSubmitter){
          sv.textContent = 'Submitter';
          sv.classList.add('submitter');
        } else {
          const raw = song.scores?.[person];
          if(raw===undefined || raw==='' || Number.isNaN(parseFloat(raw))){
            sv.textContent = '-';
          } else {
            sv.textContent = String(raw);
            if(maxNames.has(person)) sv.classList.add('high');
            if(minNames.has(person)) sv.classList.add('low');
          }
        }
        rowR.appendChild(sv);

        wrap.appendChild(rowL); wrap.appendChild(rowR);
      });

      return wrap;
    }

    function renderPosterSidebar(song, color, rank){
      const card = document.createElement('article');
      card.className = 'card poster-sidebar';
      card.dataset.id = song.id;
      card.dataset.rank = String(rank);

      const grid = document.createElement('div'); grid.className = 'poster-grid'; card.appendChild(grid);

      // Left panel
      const panel = document.createElement('div');
      panel.className = 'panel'; panel.style.gridColumn = '1'; panel.style.gridRow = '1 / -1';
      grid.appendChild(panel);

      const t = document.createElement('div'); t.className='title'; t.textContent = song.title; t.style.color = color;
      const a = document.createElement('div'); a.className='artist'; a.textContent = song.artist; a.style.color = color;
      panel.appendChild(t); panel.appendChild(a);
      if((songHasFlag(song,'anime') || songHasFlag(song,'game')) && song.sourceText){
        const s = document.createElement('div'); s.className='source'; s.textContent = song.sourceText; s.style.color = color; panel.appendChild(s);
      }

      const chip = document.createElement('div'); chip.className='hero chips';
      const rankEl = document.createElement('div'); rankEl.className='rank'; rankEl.textContent = 'Ranking: ' + placeText(rank); rankEl.style.color = color;
      const avgEl = document.createElement('div'); avgEl.className='avgnum'; avgEl.textContent = 'Average: ' + (Number.isFinite(song.avg)? song.avg.toFixed(2) : '-'); avgEl.style.color = color;
      chip.appendChild(rankEl); chip.appendChild(avgEl);
      panel.appendChild(chip);

      const lbl = document.createElement('div'); lbl.textContent = 'Scores';
      panel.appendChild(lbl);
      panel.appendChild(buildScoresList(roster, song, 'rail-scores'));

      const spacer = document.createElement('div'); spacer.style.gridColumn = '2'; spacer.style.gridRow = '1 / -1'; grid.appendChild(spacer);

      const actions = document.createElement('div'); actions.className='card-actions';
      const dl = document.createElement('button'); dl.textContent = 'Export PNG'; dl.type='button';
      dl.addEventListener('click', ()=> downloadCardPNG(card, `${rank} (${sanitizeFilename(song.title)}).png`) );
      const del = document.createElement('button'); del.textContent = 'Delete'; del.type='button';
      del.addEventListener('click', ()=>{ songs = songs.filter(s=>s.id!==song.id); rerenderCards(); if(!songs.length){ showEmpty(); } });
      actions.appendChild(dl); actions.appendChild(del);
      card.appendChild(actions);

      return card;
    }

    function renderCard(song){
      const rank = ranksMap.get(song.id) ?? 0;
      const color = placementColor(rank);
      return renderPosterSidebar(song, color, rank); // Sidebar-only
    }

    function showEmpty(){ const div = document.createElement('div'); div.className='empty'; div.id='emptyState'; div.textContent='No songs yet ‚Äî add one above ‚ú®'; cardsEl.appendChild(div); }

    /* ========== Export helpers ========== */
    async function downloadCardPNG(cardEl, filename){
      const actions = cardEl.querySelector('.card-actions');
      const prevDisplay = actions ? actions.style.display : '';
      if(actions) actions.style.display = 'none';

      const originalBG = cardEl.style.backgroundColor;
      const originalBorder = cardEl.style.borderColor;
      cardEl.style.backgroundColor = 'transparent';
      cardEl.style.borderColor = 'transparent';

      const canvas = await html2canvas(cardEl, {backgroundColor:null, scale:2});
      const url = canvas.toDataURL('image/png');
      const a = document.createElement('a'); a.href=url; a.download=filename; a.click();

      cardEl.style.backgroundColor = originalBG; cardEl.style.borderColor = originalBorder;
      if(actions) actions.style.display = prevDisplay;
    }
    async function exportElementPNG(el, filename){
      if(!el) return;
      const hidden = [];
      el.querySelectorAll('[data-hide-on-export]').forEach(node=>{
        hidden.push({ node, prevDisplay: node.style.display });
        node.style.display = 'none';
      });
      const canvas = await html2canvas(el, { backgroundColor:null, scale:2, useCORS:true, allowTaint:true });
      const url = canvas.toDataURL('image/png');
      const a = document.createElement('a'); a.href = url; a.download = filename; document.body.appendChild(a); a.click(); a.remove();
      hidden.forEach(({node, prevDisplay})=> node.style.display = prevDisplay);
    }
    exportAllBtn.addEventListener('click', async()=>{
      const cards = [...document.querySelectorAll('.card')];
      for(const c of cards){
        const title = c.querySelector('.title')?.textContent?.trim() || 'song';
        const rank = c.dataset.rank ? parseInt(c.dataset.rank,10) : 0;
        const fname = `${rank} (${sanitizeFilename(title)}).png`;
        await downloadCardPNG(c, fname);
      }
    });
    exportStatsChartBtn.addEventListener('click', ()=> exportElementPNG(document.getElementById('peopleChart'), 'people-ranking-chart.png'));
    exportStatsPanelBtn.addEventListener('click', ()=> exportElementPNG(document.getElementById('peopleStats'), 'people-stats-table.png'));
    exportAffinityBtn?.addEventListener('click', ()=> exportElementPNG(affinitySectionEl, 'affinity.png'));
    exportJointAffinityBtn?.addEventListener('click', ()=> exportElementPNG(jointAffinitySectionEl, 'joint-affinity.png'));

    sortByEl.addEventListener('change', ()=>{
	  applyCurrentSort();
	  cardsEl.innerHTML=''; document.getElementById('emptyState')?.remove();
	  songs.forEach(s=> cardsEl.appendChild(renderCard(s)));
	  document.querySelectorAll('.title, .artist, .source, .hero .rank, .hero .avgnum')
		.forEach(el=>{ shrinkToFit(el); resizeObserver.observe(el); });

	  renderPeopleChart(); renderPeopleStatsTable(); renderAffinity(); renderJointAffinity();
	});


    /* ========== Add / Clear ========== */
    songForm.addEventListener('submit', (e)=>{
      e.preventDefault();
      const title = norm(titleEl.value);
      const artist = norm(artistEl.value);
      const submitter = norm(submitterEl.value);
      const avgOverride = parseFloat(document.getElementById('avgOverride').value);

      const scores = {};
      const favorites = {};
      const flags = activeFlags();
      const guesses = {};

      [...scoreInputsEl.querySelectorAll('input[type="number"]')].forEach(inp=>{
        const who = inp.dataset.person; const val = inp.value.trim();
        if(!inp.disabled){
          if(val==='') { /* blank handled in renderer */ }
          else if(!Number.isNaN(parseFloat(val))) scores[who] = parseFloat(val);
        }
      });
      // favorites from toggles
      scoreInputsEl.querySelectorAll('.fav-toggle[aria-pressed="true"]').forEach(btn=>{
        favorites[btn.dataset.person] = true;
      });

      if(flags.anonymous){
        scoreInputsEl.querySelectorAll('select.guess-input').forEach(sel=>{
          const who = sel.dataset.person; const what = norm(sel.value);
          if(what) guesses[who] = what;
        });
      }

      const avg = Number.isFinite(avgOverride) ? avgOverride : computeAverage(scores);
      const sourceText = norm(sourceInputEl.value);
      const song = {
        id: uid(), title, artist, submitter,
        avg, scores, favorites, sourceText,
        guesses: flags.anonymous ? guesses : {},
        flags: { ...flags }
      };
      addSong(song);
      songForm.reset(); updateSourceFieldVisibility(); rebuildScoreInputs();
    });

    document.getElementById('clearForm').addEventListener('click', ()=>{
      songForm.reset(); updateSourceFieldVisibility(); rebuildScoreInputs();
    });

    function addSong(data){
      songs.push(data); rerenderCards(); renderPeopleChart(); renderPeopleStatsTable(); renderAffinity(); renderJointAffinity();
    }

	function rerenderCards(){
	  applyCurrentSort();
	  cardsEl.innerHTML = ''; document.getElementById('emptyState')?.remove();
	  songs.forEach(song=> cardsEl.appendChild(renderCard(song)));
	  document.querySelectorAll('.title, .artist, .source, .hero .rank, .hero .avgnum')
		.forEach(el=>{ shrinkToFit(el); resizeObserver.observe(el); });
	}

    function refreshAllCards(){
	  applyCurrentSort();
	  cardsEl.innerHTML = ''; document.getElementById('emptyState')?.remove();
	  songs.forEach(song=> cardsEl.appendChild(renderCard(song)));
	  document.querySelectorAll('.title, .artist, .source, .hero .rank, .hero .avgnum')
		.forEach(el=>{ shrinkToFit(el); resizeObserver.observe(el); });
	}


    /* ========== People Stats / Affinity ========== */
    function computePeopleStats(){
      const base = {};
      roster.forEach(name=>{
        base[name] = {
          name,
          givenVals: [],
          receivedVals: [],
          favMarksReceived: 0,
          greensGiven: 0,
          redsGiven: 0,
          correctGuesses: 0
        };
      });

      songs.forEach(song=>{
        const sub = norm(song.submitter);
        // received + favorites
        if(sub && base[sub]){
          Object.entries(song.scores || {}).forEach(([voter,val])=>{
            const num = Number(val);
            if(Number.isFinite(num) && lc(voter) !== lc(sub)){
              base[sub].receivedVals.push(num);
            }
          });
          const favs = song.favorites || {};
          Object.entries(favs).forEach(([voter,flag])=>{
            if(flag && lc(voter) !== lc(sub)) base[sub].favMarksReceived += 1;
          });
        }
        // voters: given + green/red
        const {maxNames, minNames} = getExtrema(song.scores || {});
        roster.forEach(person=>{
          const isSubmitter = sub && lc(person) === lc(sub);
          const val = Number(song.scores?.[person]);
          if(!isSubmitter && Number.isFinite(val)) base[person].givenVals.push(val);
        });
        maxNames.forEach(n=>{ if(base[n]) base[n].greensGiven += 1; });
        minNames.forEach(n=>{ if(base[n]) base[n].redsGiven += 1; });

        // anonymous guesses ‚Üí correctness
        if(songHasFlag(song,'anonymous')){
          Object.entries(song.guesses || {}).forEach(([voter, guessedName])=>{
            if(lc(guessedName) === lc(sub) && lc(voter)!==lc(sub)){
              base[voter].correctGuesses += 1;
            }
          });
        }
      });

      const avg = arr => arr.length ? arr.reduce((a,b)=>a+b,0)/arr.length : NaN;
      ensureCommentKeys();

      return Object.values(base).map(p=>({
        name: p.name,
        avgGiven: avg(p.givenVals),
        avgReceived: avg(p.receivedVals),
        favorited: p.favMarksReceived,
        greensGiven: p.greensGiven,
        redsGiven: p.redsGiven,
        comments: Number.isFinite(commentCounts[p.name]) ? commentCounts[p.name] : (parseInt(commentCounts[p.name],10) || 0),
        correctGuesses: p.correctGuesses || 0
      }));
    }

    function renderPeopleChart(){
      const stats = computePeopleStats();
      const ranked = [...stats].sort((a,b)=>{
        const A = Number.isFinite(a.avgReceived) ? a.avgReceived : -Infinity;
        const B = Number.isFinite(b.avgReceived) ? b.avgReceived : -Infinity;
        return B - A;
      });

      // Chart (Avg received)
      statsChartEl.innerHTML = '';
      const maxVal = 10;
      ranked.forEach((row, idx)=>{
        const rowEl = document.createElement('div');
        rowEl.className = 'chart-row';
        const left = document.createElement('div');
        left.className = 'chart-name';
        left.style.display = 'flex'; left.style.alignItems = 'center'; left.style.gap = '6px';
        const img = personAvatarEl(row.name); img.style.width='18px'; img.style.height='18px';
        const label = document.createElement('span'); label.textContent = `${idx+1}. ${row.name}`;
        left.appendChild(img); left.appendChild(label);
        rowEl.appendChild(left);

        const wrap = document.createElement('div'); wrap.className = 'chart-bar-wrap';
        const bar = document.createElement('div'); bar.className = 'chart-bar'; bar.style.background = chartGradient(statsColor);
        const ratio = Number.isFinite(row.avgReceived) ? Math.max(0, Math.min(1, row.avgReceived / maxVal)) : 0;
        bar.style.width = (ratio * 100) + '%';
        const val = document.createElement('div'); val.className = 'chart-val'; val.textContent = Number.isFinite(row.avgReceived) ? row.avgReceived.toFixed(2) : '-';
        wrap.appendChild(bar); wrap.appendChild(val);
        rowEl.appendChild(wrap);
        statsChartEl.appendChild(rowEl);
      });
    }

    function renderPeopleStatsTable(){
      const stats = computePeopleStats();
      const ranked = [...stats].sort((a,b)=>{
        const A = Number.isFinite(a.avgReceived) ? a.avgReceived : -Infinity;
        const B = Number.isFinite(b.avgReceived) ? b.avgReceived : -Infinity;
        return B - A;
      });

      // Max/min for highlighting
      const recvVals = ranked.map(r => Number.isFinite(r.avgReceived) ? r.avgReceived : null).filter(v=>v!=null);
      const globalMaxRecv = recvVals.length ? Math.max(...recvVals) : NaN;
      const globalMinRecv = recvVals.length ? Math.min(...recvVals) : NaN;

      const givenVals = ranked.map(r => Number.isFinite(r.avgGiven) ? r.avgGiven : null).filter(v=>v!=null);
      const globalMaxGiven = givenVals.length ? Math.max(...givenVals) : NaN;
      const globalMinGiven = givenVals.length ? Math.min(...givenVals) : NaN;

      const favVals = ranked.map(r => r.favorited || 0);
      const globalMaxFav = favVals.length ? Math.max(...favVals) : 0;

      const commentsVals = ranked.map(r => Number.isFinite(r.comments) ? r.comments : 0);
      const globalMaxComments = commentsVals.length ? Math.max(...commentsVals) : 0;

      const greensVals = ranked.map(r => r.greensGiven || 0);
      const greensMax = greensVals.length ? Math.max(...greensVals) : 0;
      const greensMin = greensVals.length ? Math.min(...greensVals) : 0;

      const redsVals = ranked.map(r => r.redsGiven || 0);
      const redsMax = redsVals.length ? Math.max(...redsVals) : 0;
      const redsMin = redsVals.length ? Math.min(...redsVals) : 0;

      const guessedVals = ranked.map(r => r.correctGuesses || 0);
      const maxGuessed = guessedVals.length ? Math.max(...guessedVals) : 0;
      const minGuessed = guessedVals.length ? Math.min(...guessedVals) : 0;
      const anyGuesses = guessedVals.some(v=>v>0);

      statsTableEl.innerHTML = '';
      const table = document.createElement('table');
      const thead = document.createElement('thead');
      thead.innerHTML = `
        <tr>
          <th>Rank</th>
          <th>Person</th>
          <th title="Average score others gave to their submissions">Avg (received)</th>
          <th title="Average score they gave to others">Avg (given)</th>
          <th title="Total favorites their submissions received">Favorited ‚òÖ</th>
          <th title="Manual count you set">üó£Ô∏è Comments</th>
          ${anyGuesses ? '<th title="Correct anonymous guesses">Guessed ‚úì</th>' : ''}
          <th>Greens</th>
          <th>Reds</th>
        </tr>`;
      table.appendChild(thead);

      const tbody = document.createElement('tbody');
      ranked.forEach((p, i)=>{
        const tr = document.createElement('tr');

        const tdRank = document.createElement('td'); tdRank.textContent = String(i+1); tr.appendChild(tdRank);

        const tdName = document.createElement('td');
        tdName.style.display = 'flex'; tdName.style.alignItems='center'; tdName.style.gap='8px';
        tdName.appendChild(personAvatarEl(p.name));
        const nm = document.createElement('span'); nm.textContent = p.name; tdName.appendChild(nm);
        tr.appendChild(tdName);

        const tdRecv = document.createElement('td');
        const recv = Number.isFinite(p.avgReceived) ? p.avgReceived.toFixed(2) : '-';
        tdRecv.innerHTML = `<span class="pill ${p.avgReceived===globalMaxRecv?'green':(p.avgReceived===globalMinRecv?'red':'')}">${recv}</span>`;
        tr.appendChild(tdRecv);

        const tdGiven = document.createElement('td');
        const given = Number.isFinite(p.avgGiven) ? p.avgGiven.toFixed(2) : '-';
        tdGiven.innerHTML = `<span class="pill ${p.avgGiven===globalMaxGiven?'green':(p.avgGiven===globalMinGiven?'red':'')}">${given}</span>`;
        tr.appendChild(tdGiven);

        const tdFav = document.createElement('td');
        tdFav.innerHTML = `<span class="pill ${p.favorited===globalMaxFav && globalMaxFav>0 ? 'gold' : ''}">${p.favorited||0}</span>`;
        tr.appendChild(tdFav);

        const tdComments = document.createElement('td');
        const commentsHighlight = (globalMaxComments > 0) && (p.comments === globalMaxComments);
        tdComments.innerHTML = `<span class="pill ${commentsHighlight ? 'green' : ''}">${p.comments||0}</span>`;
        tr.appendChild(tdComments);

        if(anyGuesses){
          const tdGuess = document.createElement('td');
          const cls = (p.correctGuesses===maxGuessed && maxGuessed>0 ? 'green' : (p.correctGuesses===minGuessed && maxGuessed>0 ? 'red' : ''));
          tdGuess.innerHTML = `<span class="pill ${cls}">${p.correctGuesses||0}</span>`;
          tr.appendChild(tdGuess);
        }

        const tdG = document.createElement('td');
        tdG.innerHTML = `<span class="pill ${p.greensGiven===greensMax && greensMax>0 ? 'green' : (p.greensGiven===greensMin ? 'red' : '')}">${p.greensGiven||0}</span>`;
        tr.appendChild(tdG);

        const tdR = document.createElement('td');
        tdR.innerHTML = `<span class="pill ${p.redsGiven===redsMin ? 'green' : (p.redsGiven===redsMax && redsMax>0 ? 'red' : '')}">${p.redsGiven||0}</span>`;
        tr.appendChild(tdR);

        tbody.appendChild(tr);
      });
      table.appendChild(tbody);
      statsTableEl.appendChild(table);
    }

    /* ========== Affinity (A -> B) ========== */
    function computeDirectionalAffinity(){
      const bySubmitter = {};
      songs.forEach((s, idx)=>{
        const sub = norm(s.submitter);
        if(!bySubmitter[sub]) bySubmitter[sub] = [];
        bySubmitter[sub].push(idx);
      });

      const A = {}; // A[voter][submitter] = avg score
      roster.forEach(a=>{ A[a] = {}; });

      roster.forEach(voter=>{
        roster.forEach(sub=>{
          if(lc(voter)===lc(sub)) return;
          const songIdxs = bySubmitter[sub] || [];
          const vals = [];
          songIdxs.forEach(si=>{
            const val = Number(songs[si].scores?.[voter]);
            if(Number.isFinite(val)) vals.push(val);
          });
          if(vals.length) A[voter][sub] = vals.reduce((x,y)=>x+y,0)/vals.length;
        });
      });
      return A;
    }

    function renderAffinity(){
      const A = computeDirectionalAffinity();
      affinityTableEl.innerHTML = '';
      const table = document.createElement('table');
      const thead = document.createElement('thead');
      const hdr = document.createElement('tr');
      hdr.innerHTML = `<th>Voter ‚Üì / Submitter ‚Üí</th>` + roster.map(n=>`<th>${n}</th>`).join('');
      thead.appendChild(hdr); table.appendChild(thead);
      const tbody = document.createElement('tbody');

      roster.forEach(voter=>{
        // compute row min/max (exclude self and undefined)
        const rowVals = roster
          .filter(sub=> lc(sub)!==lc(voter))
          .map(sub => A[voter]?.[sub])
          .filter(v => Number.isFinite(v));
        const rowMax = rowVals.length ? Math.max(...rowVals) : NaN;
        const rowMin = rowVals.length ? Math.min(...rowVals) : NaN;

        const tr = document.createElement('tr');
        const tdL = document.createElement('td');
        tdL.style.display='flex'; tdL.style.alignItems='center'; tdL.style.gap='8px';
        tdL.appendChild(personAvatarEl(voter));
        const nm = document.createElement('span'); nm.textContent = voter; tdL.appendChild(nm);
        tr.appendChild(tdL);

        roster.forEach(sub=>{
          const td = document.createElement('td');
          if(lc(voter)===lc(sub)){ td.textContent = '‚Äî'; }
          else{
            const v = A[voter]?.[sub];
            let cls = '';
            if(Number.isFinite(v)){
              if(v === rowMax) cls = 'best';
              if(v === rowMin) cls = (rowMax!==rowMin ? 'worst' : '');
              td.innerHTML = `<span class="aff-num ${cls}">${v.toFixed(2)}</span>`;
            } else {
              td.textContent = '‚Äî';
            }
          }
          tr.appendChild(td);
        });

        tbody.appendChild(tr);
      });
      table.appendChild(tbody);
      affinityTableEl.appendChild(table);
    }

    /* ========== Joint Affinity (LIST with A‚ÜíB, B‚ÜíA, Joint, Bar) ========== */
    function renderJointAffinity(){
      const A = computeDirectionalAffinity();

      const pairs = [];
      for(let i=0;i<roster.length;i++){
        for(let j=i+1;j<roster.length;j++){
          const p = roster[i], q = roster[j];
          const ab = A[p]?.[q];
          const ba = A[q]?.[p];
          const both = [ab,ba].filter(v=>Number.isFinite(v));
          if(both.length){
            const joint = both.reduce((x,y)=>x+y,0)/both.length;
            pairs.push({ a:p, b:q, ab, ba, joint });
          }
        }
      }
      pairs.sort((x,y)=> y.joint - x.joint);

      jointAffinityListEl.innerHTML = '';
      const maxVal = 10;
		// Header row
		const header = document.createElement('div');
		header.className = 'pair-row pair-header';
		const hA = document.createElement('div'); hA.className = 'pair-left';  hA.innerHTML  = '<span>Person A</span>';
		const hArrow = document.createElement('div'); hArrow.className = 'pair-arrow'; hArrow.textContent = '‚Üî';
		const hB = document.createElement('div'); hB.className = 'pair-right'; hB.innerHTML = '<span>Person B</span>';
		const hAB = document.createElement('div'); hAB.className = 'pair-num'; hAB.textContent = 'A‚ÜíB';
		const hBA = document.createElement('div'); hBA.className = 'pair-num'; hBA.textContent = 'B‚ÜíA';
		const hJ  = document.createElement('div'); hJ.className  = 'pair-num'; hJ.textContent  = 'Joint';
		const hBar= document.createElement('div'); hBar.className = 'pair-bar-label'; hBar.textContent = 'Score';
		header.append(hA, hArrow, hB, hAB, hBA, hJ, hBar);
		jointAffinityListEl.appendChild(header);



      pairs.forEach(({a,b,ab,ba,joint})=>{
        const rowEl = document.createElement('div');
        rowEl.className = 'pair-row';

        const left = document.createElement('div'); left.className='pair-left';
        left.appendChild(personAvatarEl(a));
        left.appendChild(Object.assign(document.createElement('span'), {textContent:a}));

        const arrow = document.createElement('div'); arrow.className='pair-arrow'; arrow.textContent = '‚Üî';

		const right = document.createElement('div'); right.className='pair-right';
		const rightName = document.createElement('span');
		rightName.textContent = b;
		right.appendChild(rightName);
		right.appendChild(personAvatarEl(b)); // avatar to the right of the name


        const cAB = document.createElement('div'); cAB.className='pair-num'; cAB.textContent = Number.isFinite(ab) ? ab.toFixed(2) : '‚Äî';
        const cBA = document.createElement('div'); cBA.className='pair-num'; cBA.textContent = Number.isFinite(ba) ? ba.toFixed(2) : '‚Äî';
        const cJ  = document.createElement('div'); cJ.className='pair-num';  cJ.textContent  = Number.isFinite(joint) ? joint.toFixed(2) : '‚Äî';

        const wrap = document.createElement('div'); wrap.className = 'chart-bar-wrap';
        const bar = document.createElement('div'); bar.className = 'chart-bar'; bar.style.background = chartGradient(jointColor);
        const ratio = Math.max(0, Math.min(1, (Number.isFinite(joint) ? joint : 0) / maxVal));
        bar.style.width = (ratio * 100) + '%';
        const val = document.createElement('div'); val.className = 'chart-val'; val.textContent = Number.isFinite(joint) ? joint.toFixed(2) : '‚Äî';
        wrap.appendChild(bar); wrap.appendChild(val);

        rowEl.appendChild(left);
        rowEl.appendChild(arrow);
        rowEl.appendChild(right);
        rowEl.appendChild(cAB);
        rowEl.appendChild(cBA);
        rowEl.appendChild(cJ);
        rowEl.appendChild(wrap);

        jointAffinityListEl.appendChild(rowEl);
      });

      if(pairs.length===0){
        const msg = document.createElement('div');
        msg.className='hints';
        msg.textContent = 'No joint affinity yet ‚Äî add some songs and scores.';
        jointAffinityListEl.appendChild(msg);
      }
    }

    /* ========== CSV/TSV utils ========== */
    function autoDelimiterGeneric(text){
      const counts = { ',':0, '\t':0, ';':0 };
      const lines = text.split(/\r?\n/).slice(0,5);
      lines.forEach(line=>{
        counts[','] += (line.match(/,/g)||[]).length;
        counts['\t'] += (line.match(/\t/g)||[]).length;
        counts[';'] += (line.match(/;/g)||[]).length;
      });
      let best = ','; let maxc = counts[','];
      if(counts['\t']>maxc){ best='\t'; maxc=counts['\t']; }
      if(counts[';']>maxc){ best=';'; maxc=counts[';']; }
      return best;
    }
    function parseDelimited(text, delim){
      const rows = [];
      let i=0, cur='', inQuotes=false;
      function pushCell(){ cur = cur.replace(/^\s+|\s+$/g,''); cells.push(cur); cur=''; }
      let cells=[];
      while(i<=text.length){
        const ch = text[i] || '\n';
        if(ch==='"'){ if(inQuotes && text[i+1]==='"'){ cur+='"'; i++; } else { inQuotes=!inQuotes; } }
        else if(!inQuotes && (ch===delim || ch==='\n' || ch==='\r')){
          pushCell();
          if(ch===delim){ i++; continue; }
          if(ch==='\r' && text[i+1]==='\n') i++;
          rows.push(cells); cells=[];
        } else { cur+=ch; }
        i++;
      }
      if(cells.length) rows.push(cells);
      return rows.filter(r=>r.length && r.some(c=>norm(c).length));
    }

    function ensureRosterFromHeaders(headers){
      headers.forEach(h=>{
        const key = lc(h);
        if(!RESERVED_HEADERS.has(key)){
          const exists = roster.some(n=> lc(n)===key );
          if(!exists){ roster.push(h); peopleCountEl.value = roster.length; }
        }
      });
      renderRosterInputs(); fillDatalist();
    }

    /* ========== Bulk Scores Import ========== */
    openBulkBtn.addEventListener('click', ()=>{ bulkDialog.showModal(); });
    cancelBulkBtn.addEventListener('click', ()=> bulkDialog.close());

    bulkForm.addEventListener('submit', (e)=>{
      e.preventDefault();
      const text = bulkText.value || '';
      if(!text.trim()){ bulkDialog.close(); return; }
      const delim = (delimiterEl.value==='auto') ? autoDelimiterGeneric(text) : delimiterEl.value;
      const rows = parseDelimited(text, delim);
      if(!rows.length){ bulkDialog.close(); return; }

      let headers = [];
      if(hasHeaderEl.value==='yes'){ headers = rows.shift().map(h=>norm(h)); }
      else{
        headers = rows[0].map((_,i)=> `col${i+1}`);
      }

      // Normalize header aliases
      const idx = {};
      headers.forEach((h,i)=>{
        const k = lc(h);
        if(['song','title'].includes(k)) idx.song = i;
        else if(k==='artist') idx.artist = i;
        else if(['submitter','nominator'].includes(k)) idx.submitter = i;
        else if(k==='average') idx.average = i;
        else if(k==='anime') idx.anime = i;
        else if(k==='game') idx.game = i;
      });

      // Add unknown people columns to roster
      const personHeaders = headers.filter(h=> !['song','title','artist','submitter','nominator','average','anime','game'].includes(lc(h)) );
      ensureRosterFromHeaders(personHeaders);

      rows.forEach(cells=>{
        const title = norm(cells[idx.song] ?? '');
        const artist = norm(cells[idx.artist] ?? '');
        const submitter = norm(cells[idx.submitter] ?? '');
        const avgOverride = parseFloat(cells[idx.average] ?? '');

        const scores = {};
        const favorites = {};
        const guesses = {};
        const flags = { anime:false, game:false, anonymous: activeFlags().anonymous };

        const sourceText = (()=>{
          const a = norm(cells[idx.anime] ?? '');
          const g = norm(cells[idx.game] ?? '');
          if(a){ flags.anime = true; return a; }
          if(g){ flags.game = true; return g; }
          return norm(sourceInputEl.value);
        })();

        // person columns
        headers.forEach((h, colIdx)=>{
          const key = lc(h);
          if(RESERVED_HEADERS.has(key)) return;
          const who = roster.find(n=> lc(n)===key ) || h;
          const cell = cells[colIdx];
          if(isBlankScore(cell)) return;
          const { num, favorite } = parseScoreCell(cell);
          if(Number.isFinite(num) && lc(who)!==lc(submitter)){ scores[who] = num; }
          if(favorite && lc(who)!==lc(submitter)){ favorites[who] = true; }
        });

        const avg = Number.isFinite(avgOverride) ? avgOverride : computeAverage(scores);
        const song = {
          id: uid(), title, artist, submitter,
          avg, scores, favorites, sourceText,
          guesses: flags.anonymous ? guesses : {},
          flags
        };
        addSong(song);
      });

      bulkDialog.close();
      rebuildScoreInputs();
    });

    /* ========== Bulk Guesses Import ========== */
    openBulkGuessesBtn.addEventListener('click', ()=> bulkGuessDialog.showModal());
    cancelBulkGuessBtn.addEventListener('click', ()=> bulkGuessDialog.close());

    bulkGuessForm.addEventListener('submit', (e)=>{
      e.preventDefault();
      const text = bulkGuessText.value || '';
      if(!text.trim()){ bulkGuessDialog.close(); return; }
      const delim = (guessDelimiterEl.value==='auto') ? autoDelimiterGeneric(text) : guessDelimiterEl.value;
      const rows = parseDelimited(text, delim);
      if(!rows.length){ bulkGuessDialog.close(); return; }

      let headers = [];
      if(guessHasHeaderEl.value==='yes'){ headers = rows.shift().map(h=>norm(h)); }
      else{ headers = rows[0].map((_,i)=> `col${i+1}`); }

      // Identify basic columns
      let idxSong=-1, idxArtist=-1, idxSubmitter=-1;
      headers.forEach((h,i)=>{
        const k = lc(h);
        if(['song','title'].includes(k)) idxSong = i;
        else if(k==='artist') idxArtist = i;
        else if(['submitter','nominator'].includes(k)) idxSubmitter = i;
      });

      // Add unknown people columns to roster
      const personHeaders = headers.filter(h=> !['song','title','artist','submitter','nominator'].includes(lc(h)) );
      ensureRosterFromHeaders(personHeaders);

      rows.forEach(cells=>{
        const songTitle = norm(cells[idxSong] ?? '');
        const artist = norm(cells[idxArtist] ?? '');
        const submitter = norm(cells[idxSubmitter] ?? '');

        // find matching song
        const song = songs.find(s =>
          lc(s.title)===lc(songTitle) &&
          (!artist || lc(s.artist)===lc(artist)) &&
          (!submitter || lc(s.submitter)===lc(submitter))
        );
        if(!song) return;

        if(!song.flags) song.flags = {};
        song.flags.anonymous = true;
        if(!song.guesses) song.guesses = {};

        headers.forEach((h, colIdx)=>{
          const key = lc(h);
          if(['song','title','artist','submitter','nominator'].includes(key)) return;
          const who = roster.find(n=> lc(n)===key ) || h;
          const guess = norm(cells[colIdx] ?? '');
          if(!isBlankScore(guess)) song.guesses[who] = guess;
        });
      });

      bulkGuessDialog.close();
      refreshAllCards(); renderPeopleChart(); renderPeopleStatsTable();
    });

    /* ========== Comments editor ========== */
    openCommentsBtn?.addEventListener('click', ()=>{
      commentsListEl.innerHTML = '';
      roster.forEach(name=>{
        const label = document.createElement('div'); label.textContent = name;
        const inp = document.createElement('input'); inp.type='number'; inp.step='1';
        inp.value = String(commentCounts[name] || 0);
        inp.dataset.person = name;
        commentsListEl.appendChild(label);
        commentsListEl.appendChild(inp);
      });
      commentsDialog.showModal();
    });
    commentsForm.addEventListener('submit', (e)=>{
      e.preventDefault();
      commentsListEl.querySelectorAll('input[type="number"]').forEach(inp=>{
        const who = inp.dataset.person; const v = parseInt(inp.value || '0', 10);
        commentCounts[who] = Number.isFinite(v) ? v : 0;
      });
      commentsDialog.close();
      renderPeopleChart(); renderPeopleStatsTable();
    });
    document.getElementById('cancelComments')?.addEventListener('click', ()=> commentsDialog.close());


    /* ========== Init ========== */
    function shrinkInit(){
      document.querySelectorAll('.title, .artist, .source, .hero .rank, .hero .avgnum').forEach(el=>{ shrinkToFit(el); resizeObserver.observe(el); });
    }
    function init(){
      renderRosterInputs(); fillDatalist(); rebuildScoreInputs();
      renderPeopleChart(); renderPeopleStatsTable(); renderAffinity(); renderJointAffinity();
      shrinkInit();
    }
    init();
  </script>
</body>
</html>
