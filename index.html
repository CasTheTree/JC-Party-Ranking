<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Song Scoring Dashboard</title>
  <style>
    :root{
      --bg:#0b0b0c; --ink:#e8e8ea; --muted:#a7a7ab; --accent:#7dd3fc; --card:#111114; --ring:#2a2a31;
      --green:#16a34a; --red:#dc2626; --yellow:#facc15;
      --gold:#f5c542; --silver:#c0c0c8; --bronze:#cd7f32;
    }
    html,body{height:100%}
    body{
      margin:0; font:16px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, "Helvetica Neue", Arial, "Apple Color Emoji","Segoe UI Emoji";
      background:var(--bg); color:var(--ink); display:flex; flex-direction:column;
    }
    header{position:sticky; top:0; z-index:10; backdrop-filter:saturate(1.2) blur(6px); background:linear-gradient(180deg, #0b0b0ccc, #0b0b0c80 70%, transparent);}
    .container{max-width:1100px; margin:0 auto; padding:20px;}
    h1{font-size:clamp(22px, 2.6vw, 30px); margin:0 0 8px 0}
    .toolbar{display:grid; gap:10px; grid-template-columns: repeat(12,1fr); align-items:end}
    .toolbar .block{grid-column: span 3; min-width:0}
    .toolbar .block.wide{grid-column: span 6}
    label{display:block; font-size:12px; letter-spacing:.02em; color:var(--muted); margin:0 0 4px}
    input, select, button, textarea{
      background:#0f0f12; color:var(--ink); border:1px solid var(--ring); border-radius:10px; padding:10px 12px; width:100%; outline:none;
    }
    textarea{min-height:160px}
    input[type="number"]{appearance:textfield}
    input:focus, select:focus, textarea:focus{border-color:#3b82f6; box-shadow:0 0 0 2px #3b82f640}
    button{cursor:pointer; border:1px solid #2b2b33; background:linear-gradient(180deg,#1b1b20,#121216); font-weight:600}
    button.primary{border-color:#2563eb; background:linear-gradient(180deg,#2563eb,#1d4ed8); color:white}
    button.ghost{background:transparent}
    .row{display:flex; gap:10px}

    /* Roster */
    .roster{margin-top:12px; display:grid; grid-template-columns: 1fr auto auto auto; gap:8px;}
    .roster input{width:100%}

    /* Avatars */
    .avatar{width:24px; height:24px; border-radius:6px; object-fit:cover; border:1px solid var(--ring); background:#0f0f12}
    .avatar.lg{width:28px; height:28px; border-radius:6px}

    /* Form */
    .song-form{margin-top:18px; padding:16px; border:1px dashed var(--ring); border-radius:14px}
    .song-grid{display:grid; gap:10px; grid-template-columns: repeat(12,1fr)}
    .song-grid .span4{grid-column: span 4}
    .song-grid .span12{grid-column: 1 / -1}

    /* Cards grid */
    .cards{display:grid; grid-template-columns: repeat(auto-fill, minmax(260px, 1fr)); gap:16px; margin-top:18px}

    /* Base Card (16:9) */
    .card{
      position:relative; background:var(--card); border:1px solid var(--ring); border-radius:18px; padding:16px;
      aspect-ratio:16/9; display:grid; gap:8px;
    }
    .card.compact{padding:12px; border-radius:14px}
    .card.borderless{border-color:transparent; background:transparent}

    /* Title/Artist */
    .title{font-size:18px; font-weight:800; line-height:1.15; white-space:nowrap; overflow:hidden}
    .artist{font-size:14px; color:var(--muted); margin-top:-2px; border-bottom:1px dashed var(--ring); padding-bottom:8px; white-space:nowrap; overflow:hidden}

    /* Hero */
    .hero{
      display:grid; grid-template-columns:auto auto; justify-content:center; align-items:baseline; gap:14px; margin-top:4px;
    }
    .hero .rank, .hero .avgnum{ font-size:18px; font-weight:800; line-height:1.15; white-space:nowrap; overflow:hidden; }

    /* Score grid */
    .scores{
      display:grid; grid-template-columns: 1fr auto;
      row-gap:8px; column-gap:8px; align-items:center;
      grid-auto-rows: 28px;
    }
    .badge{ display:grid; grid-template-columns: auto 1fr auto; align-items:center; gap:8px; min-width:0; }
    .name{font-size:12px; color:var(--muted); white-space:nowrap; overflow:hidden; text-overflow:ellipsis;}
    .score-cell{ text-align:right; display:flex; align-items:center; justify-content:flex-end; gap:4px; }
    .score{font-variant-numeric:tabular-nums; font-weight:700; display:inline-block; min-width:3.5ch; text-align:right}
    .score.high{color:var(--green)} .score.low{color:var(--red)}
    .markSubmitter{ display:inline-flex; align-items:center; justify-content:center; height:18px; padding:0 6px; border-radius:6px; background:var(--yellow); color:#111; font-size:11px; font-weight:900 }

    .card-actions{display:flex; gap:8px; margin-top:auto}
    .empty{border:1px dashed var(--ring); border-radius:14px; padding:20px; color:var(--muted); text-align:center}
    .favStar{ font-weight:900; margin-right:4px; color:var(--yellow); }

    /* Dialog */
    dialog{border:1px solid var(--ring); border-radius:14px; background:#0f0f12; color:var(--ink); padding:16px; max-width:860px}
    dialog::backdrop{background:rgba(0,0,0,.6)}
    .grid{display:grid; gap:10px; grid-template-columns: repeat(12,1fr)}
    .span6{grid-column: span 6} .span8{grid-column: span 8} .span12{grid-column: 1 / -1}
    .hints{font-size:12px; color:var(--muted)}

    /* ---------- Poster Layouts ---------- */

    .poster-grid{position:relative; width:100%; height:100%; display:grid;}

    /* Panels/chips/footers are FULLY transparent (no fill, no border) */
    .panel{ background:transparent; border:none; border-radius:14px; padding:14px; height:100%; overflow:hidden; }
    .top-chip{ background:transparent; border:none; border-radius:12px; padding:10px 14px; display:inline-grid; grid-auto-flow:column; gap:14px; }
    .footer{ background:transparent; border:none; border-radius:14px; padding:12px 16px; min-width:62%; }

    /* Sidebar Left ‚Äî transparent card shell */
    .card.poster-sidebar{ padding:16px; background:transparent; border-color:transparent; }
    .card.poster-sidebar .poster-grid{
      grid-template-columns: 280px 1fr; grid-template-rows: 1fr; column-gap:16px; height:100%;
    }

    /* Split Sides ‚Äî transparent card shell */
    .card.poster-split{ padding:16px; background:transparent; border-color:transparent; }
    .card.poster-split .poster-grid{
      grid-template-columns: 280px 1fr 280px;    /* rails + middle */
      grid-template-rows: auto 1fr auto;        /* top chip | body | footer */
      row-gap: 12px; column-gap: 16px; height:100%;
    }
    /* Split footer sits only in the center column to avoid rail overlap */
    .card.poster-split .footer{ grid-column:2; grid-row:3; justify-self:center; }
    .card.poster-split .top-chip{ grid-column:2; grid-row:1; justify-self:center; align-self:start; }

    /* ===== People Stats ===== */
    .stats-card{
      position:relative; background:var(--card); border:1px solid var(--ring); border-radius:18px; padding:16px;
    }
    .stats-head{display:flex; align-items:center; justify-content:space-between; gap:12px; margin-top:18px}
    .stats-title{font-weight:800; font-size:18px}
    .stats-wrap{display:grid; grid-template-columns: 1.1fr 1fr; gap:16px; margin-top:12px}
    .stats-chart{
      border:1px dashed var(--ring); border-radius:14px; padding:12px; overflow:auto; background:transparent;
    }
    .stats-table{
      border:1px dashed var(--ring); border-radius:14px; overflow:auto;
    }
    table{width:100%; border-collapse:collapse; font-size:14px}
    th, td{padding:8px 10px; border-bottom:1px solid var(--ring); text-align:left; white-space:nowrap}
    th{font-size:12px; color:var(--muted); position:sticky; top:0; background:linear-gradient(180deg,#101014,#0b0b0c);}
    .pill{font-variant-numeric:tabular-nums; font-weight:800}
    .pill.green{color:var(--green)} .pill.red{color:var(--red)}
    .rank-badge{font-weight:900}
    .chart-row{display:flex; align-items:center; gap:10px; margin:6px 0}
    .chart-name{width:140px; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; font-size:12px; color:var(--muted)}
    .chart-bar-wrap{flex:1; height:22px; border-radius:8px; background:linear-gradient(180deg,#111114,#0f0f12); border:1px solid var(--ring); position:relative}
    .chart-bar{height:100%; border-radius:8px; background:linear-gradient(180deg,#2563eb,#1d4ed8)}
    .chart-val{position:absolute; right:6px; top:0; bottom:0; display:flex; align-items:center; font-variant-numeric:tabular-nums; font-weight:800}
    .export-row{display:flex; gap:8px}
	.chart-bar.best{ background: var(--green) !important; }
	.chart-bar.worst{ background: var(--red) !important; }
	/* Affinity numeric cells (no bars) */
	.aff-num{ font-variant-numeric: tabular-nums; font-weight:800 }
	.aff-num.best{ color: var(--green); }
	.aff-num.worst{ color: var(--red); }

	/* Gold highlight for "Favorited" leaders */
	.pill.gold{ color: var(--gold); }

	/* Tiny avatars in stats tables */
	.stats-table .avatar{ width:22px; height:22px; border-radius:6px; }


    @media (max-width:980px){
      .stats-wrap{grid-template-columns:1fr}
    }

    @media (max-width:840px){
      .toolbar .block{grid-column: span 6}
      .toolbar .block.wide{grid-column: 1 / -1}
      .song-grid .span4{grid-column: span 6}
      .span6{grid-column: 1 / -1}
      .span8{grid-column: 1 / -1}
    }
  </style>
</head>
<body>
  <header>
    <div class="container">
      <h1>üéµ Song Scoring Dashboard</h1>
      <div class="toolbar" role="region" aria-label="Controls">
        <div class="block">
          <label for="peopleCount">Number of people</label>
          <input id="peopleCount" type="number" min="1" value="5" />
        </div>
        <div class="block wide">
          <label>People (names)</label>
          <div id="roster" class="roster" aria-live="polite"></div>
        </div>
        <div class="block">
          <label for="layoutStyle">Layout</label>
          <select id="layoutStyle">
            <option value="standard">Standard</option>
            <option value="compact">Compact</option>
            <option value="borderless">Borderless / Transparent</option>
            <option value="poster-sidebar">Poster: Sidebar Left</option>
            <option value="poster-split">Poster: Split Sides</option>
          </select>
        </div>
        <div class="block">
          <label for="sortBy">Sort by</label>
          <select id="sortBy">
            <option value="avg_desc">Ranking (High ‚Üí Low)</option>
            <option value="avg_asc">Average (Low ‚Üí High)</option>
            <option value="title_asc">Title (A ‚Üí Z)</option>
            <option value="artist_asc">Artist (A ‚Üí Z)</option>
          </select>
        </div>
        <div class="block">
          <label>&nbsp;</label>
          <button id="exportAll" title="Export all cards as transparent PNGs">Export All PNGs</button>
        </div>
        <div class="block">
          <label>&nbsp;</label>
          <button id="downloadPage" title="Save this dashboard as a single HTML file">Download .html</button>
        </div>
        <div class="block">
          <label>&nbsp;</label>
          <button id="openBulk" class="primary" title="Paste from Google Slides/Sheets">Bulk add (paste CSV/TSV)</button>
        </div>
      </div>

      <form id="songForm" class="song-form" autocomplete="off">
        <div class="song-grid">
          <div class="span4">
            <label for="title">Song title</label>
            <input id="title" required placeholder="e.g., This Song" />
          </div>
          <div class="span4">
            <label for="artist">Artist</label>
            <input id="artist" required placeholder="e.g., Music Man" />
          </div>
          <div class="span4">
            <label for="submitter">Submitter</label>
            <input id="submitter" required placeholder="Pick from roster or type" list="rosterList" />
            <datalist id="rosterList"></datalist>
          </div>
          <div class="span12">
            <label>Scores (per person)</label>
            <div id="scoreInputs" class="row" style="flex-wrap:wrap"></div>
          </div>
          <div class="span4">
            <label for="avgOverride">Average (optional ‚Äî you can paste yours)</label>
            <input id="avgOverride" type="number" step="0.01" placeholder="Leave blank to auto-calc" />
          </div>
          <div class="span4">
            <label>&nbsp;</label>
            <button class="primary" type="submit">Add song</button>
          </div>
          <div class="span4">
            <label>&nbsp;</label>
            <button type="button" id="clearForm" class="ghost">Clear</button>
          </div>
        </div>
      </form>
    </div>
  </header>

  <main class="container" style="padding-top:6px; padding-bottom:40px">
    <!-- ===== People Stats (Exportable) ===== -->
    <section id="peopleStats" class="stats-card" aria-live="polite">
      <div class="stats-head">
        <div class="stats-title">üë§ People Stats ‚Äî Ranking by Avg (received)</div>
		<div class="export-row">
		  <label for="statsColor" class="name" style="align-self:center">Graph color</label>
		  <select id="statsColor" style="width:auto">
			<option value="blue" selected>Blue</option>
			<option value="green">Green</option>
			<option value="red">Red</option>
			<option value="purple">Purple</option>
			<option value="pink">Pink</option>
			<option value="gold">Gold</option>
			<option value="gray">Gray</option>
		  </select>
		  <button id="exportStatsChart" title="Export chart as transparent PNG">Export Chart PNG</button>
		  <button id="exportStatsPanel" title="Export entire stats panel as transparent PNG">Export Panel PNG</button>
		</div>
      </div>
      <div class="stats-wrap" id="statsWrap">
        <div class="stats-chart" id="statsChart" aria-label="Ranking chart (higher is better)"></div>
        <div class="stats-table" id="statsTable" aria-label="Per-person details"></div>
      </div>
    </section>
	
	<!-- ===== Affinity (Exportable) ===== -->
	<section id="affinitySection" class="stats-card" aria-live="polite">
	  <div class="stats-head">
		<div class="stats-title">ü§ù Affinity ‚Äî who likes whose songs</div>
		<div class="export-row">
		  <button id="exportAffinity" title="Export as transparent PNG">Export Affinity PNG</button>
		</div>
	  </div>
	  <div class="stats-table" id="affinityTable"></div>
	</section>
	
	<!-- ===== Joint Affinity (Exportable) ===== -->
	<section id="jointAffinitySection" class="stats-card" aria-live="polite">
	  <div class="stats-head">
		<div class="stats-title">üîó Joint Affinity ‚Äî average of A‚ÜíB and B‚ÜíA</div>
		<div class="export-row">
		  <button id="exportJointAffinity" type="button" title="Export as transparent PNG">Export Joint Affinity PNG</button>
		</div>
	  </div>
	  <div class="stats-table" id="jointAffinityTable"></div>
	</section>

    <section id="cards" class="cards" aria-live="polite" style="margin-top:18px">
      <div class="empty" id="emptyState">No songs yet ‚Äî add one above ‚ú®</div>
    </section>
  </main>

  <!-- Bulk import dialog -->
  <dialog id="bulkDialog">
    <form method="dialog" id="bulkForm">
      <h2 style="margin:0 0 8px">Bulk add songs</h2>
      <p class="hints">Paste rows from Google <b>Slides</b> (table) or <b>Sheets</b>. Columns can be in any order as long as headers exist. Required headers: <code>song</code>, <code>artist</code>, <code>submitter</code>. Headers matching roster names will be treated as that person's score. Add * after a score to mark it as a favorite.</p>
      <div class="grid">
        <div class="span12">
          <label for="bulkText">Rows (CSV/TSV)</label>
          <textarea id="bulkText" placeholder="song\artist\submitter\Person 1\Person 2\Person 3\..."></textarea>
        </div>
        <div class="span6">
          <label for="hasHeader">First row is header</label>
          <select id="hasHeader">
            <option value="yes" selected>Yes</option>
            <option value="no">No</option>
          </select>
        </div>
        <div class="span6">
          <label for="delimiter">Delimiter</label>
          <select id="delimiter">
            <option value="auto" selected>Auto-detect</option>
            <option value=",">Comma</option>
            <option value="\t">Tab</option>
            <option value=";">Semicolon</option>
          </select>
        </div>
        <div class="span12">
          <div class="row" style="justify-content:flex-end; gap:8px">
            <button value="cancel" type="button" id="cancelBulk" class="ghost">Cancel</button>
            <button value="default" type="submit" class="primary">Import rows</button>
          </div>
        </div>
      </div>
      <details class="hints" style="margin-top:8px">
        <summary>Header examples</summary>
        <code>song,artist,submitter,Person 1,Person 2,Person 3,Person 4,Person 5</code>
      </details>
    </form>
  </dialog>

  <!-- html2canvas for export -->
  <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
  <script>
    const peopleCountEl = document.getElementById('peopleCount');
    const rosterEl = document.getElementById('roster');
    const datalistEl = document.getElementById('rosterList');
    const scoreInputsEl = document.getElementById('scoreInputs');
    const songForm = document.getElementById('songForm');
    const cardsEl = document.getElementById('cards');
    const layoutStyleEl = document.getElementById('layoutStyle');
    const sortByEl = document.getElementById('sortBy');
    const exportAllBtn = document.getElementById('exportAll');
    const downloadPageBtn = document.getElementById('downloadPage');
    const submitterEl = document.getElementById('submitter');
    const titleEl = document.getElementById('title');
    const artistEl = document.getElementById('artist');

    // Stats panel elements
    const statsChartEl = document.getElementById('statsChart');
    const statsTableEl = document.getElementById('statsTable');
    const exportStatsChartBtn = document.getElementById('exportStatsChart');
    const exportStatsPanelBtn = document.getElementById('exportStatsPanel');
    const statsSectionEl = document.getElementById('peopleStats');
	
	const statsColorEl = document.getElementById('statsColor');
	let statsColor = statsColorEl?.value || 'blue';
	statsColorEl?.addEventListener('change', () => {
	  statsColor = statsColorEl.value;
	  renderPeopleStats();
	});

	// Affinity elements
	const affinitySectionEl = document.getElementById('affinitySection');
	const affinityTableEl = document.getElementById('affinityTable');
	const exportAffinityBtn = document.getElementById('exportAffinity');
	
	// Joint Affinity elements
	const jointAffinitySectionEl = document.getElementById('jointAffinitySection');
	const jointAffinityTableEl = document.getElementById('jointAffinityTable');
	const exportJointAffinityBtn = document.getElementById('exportJointAffinity');

    // Bulk dialog
    const bulkDialog = document.getElementById('bulkDialog');
    const openBulkBtn = document.getElementById('openBulk');
    const bulkForm = document.getElementById('bulkForm');
    const bulkText = document.getElementById('bulkText');
    const hasHeaderEl = document.getElementById('hasHeader');
    const delimiterEl = document.getElementById('delimiter');
    const cancelBulkBtn = document.getElementById('cancelBulk');

    let roster = ['Person 1','Person 2','Person 3','Person 4','Person 5'];
    let photos = {}; // { [name:string]: dataUrl }
    // songs: {id,title,artist,submitter,scores:{name:number}, favorites:{name:true}, avg}
    let songs = [];
    let ranksMap = new Map(); // song.id -> rank

    // Tie-breaking
    let tieBreakers = new Map();
    const EPS = 1e-6;
    function refreshTieBreakers(){
      tieBreakers = new Map(songs.map(s => [s.id, Math.random()]));
    }

    /* utils */
    const uid = () => Math.random().toString(36).slice(2,9);
    const clamp = (n, min, max) => Math.min(Math.max(n, min), max);
    const sanitizeFilename = (s) => s.replace(/[\/:*?"<>|]/g,'_').slice(0,80);
    const readImageAsDataURL = (file) => new Promise((resolve,reject)=>{ const fr = new FileReader(); fr.onload = ()=>resolve(fr.result); fr.onerror = reject; fr.readAsDataURL(file); });

    function norm(s){return (s||'').toString().trim();}
    function lc(s){return norm(s).toLowerCase();}
    const RESERVED_HEADERS = new Set(['song','title','artist','submitter','average']);
    function isBlankScore(v){ const t = lc(v); return t===''||t==='/'||t==='na'||t==='n/a'||t==='‚Äì'||t==='‚Äî'||t==='nil'; }

    function parseScoreCell(raw){
      const txt = (raw || '').toString().trim();
      const favorite = /[*‚òÖ]/.test(txt);
      const num = parseFloat(txt.replace(/[^\d.]+/g,''));
      return { num: Number.isFinite(num) ? num : NaN, favorite };
    }

    function personAvatarEl(name, size='sm'){
      const img = document.createElement('img');
      img.className = size==='lg' ? 'avatar lg' : 'avatar';
      img.alt = name ? `${name}'s avatar` : 'avatar';
      if(photos[name]) img.src = photos[name];
      else { img.style.background = '#0f0f12'; img.style.border = '1px solid var(--ring)'; }
      return img;
    }

    function shrinkToFit(el, minPx=10){
      const style = getComputedStyle(el);
      const base = parseFloat(style.fontSize) || 18;
      el.style.fontSize = base + 'px';
      let guard = 0;
      while (el.scrollWidth > el.clientWidth && guard < 60) {
        const cur = parseFloat(getComputedStyle(el).fontSize);
        if (cur <= minPx) break;
        el.style.fontSize = (cur - 0.5) + 'px';
        guard++;
      }
    }
    const resizeObserver = new ResizeObserver(() => {
      document.querySelectorAll('.title, .artist, .hero .rank, .hero .avgnum').forEach(shrinkToFit);
    });
    window.addEventListener('resize', () => {
      document.querySelectorAll('.title, .artist, .hero .rank, .hero .avgnum').forEach(shrinkToFit);
      renderPeopleStats(); renderAffinity(); // keep bar widths responsive
    });

    function renderRosterInputs(){
      rosterEl.innerHTML = '';
      datalistEl.innerHTML = '';
      roster.forEach((name, i)=>{
        const rowName = document.createElement('input');
        rowName.value = name;
        rowName.placeholder = `Person ${i+1}`;
        rowName.addEventListener('change', ()=>{
          const oldName = roster[i];
          const newName = rowName.value.trim();
          if(photos[oldName] && !photos[newName]) photos[newName] = photos[oldName];
          if(oldName !== newName){ delete photos[oldName]; }
          roster[i] = newName;
          rebuildScoreInputs(); fillDatalist(); refreshAllCards(); renderRosterInputs(); renderPeopleStats(); renderAffinity();
        });

        const uploadBtn = document.createElement('input');
        uploadBtn.type = 'file'; uploadBtn.accept = 'image/*'; uploadBtn.title='Upload avatar'; uploadBtn.style.width='42px';
        uploadBtn.addEventListener('change', async ()=>{
          const file = uploadBtn.files?.[0]; if(!file) return;
          const dataUrl = await readImageAsDataURL(file);
          photos[roster[i]] = dataUrl; refreshAllCards(); renderRosterInputs(); rebuildScoreInputs(); renderPeopleStats(); renderAffinity();
        });

        const clearBtn = document.createElement('button'); clearBtn.textContent='üóë'; clearBtn.type='button'; clearBtn.title='Remove avatar'; clearBtn.style.width='42px';
        clearBtn.addEventListener('click', ()=>{ delete photos[roster[i]]; refreshAllCards(); renderRosterInputs(); rebuildScoreInputs(); renderPeopleStats(); renderAffinity(); });

        const removeBtn = document.createElement('button'); removeBtn.textContent='‚úï'; removeBtn.type='button'; removeBtn.title='Remove person'; removeBtn.style.width='42px';
        removeBtn.addEventListener('click', ()=>{
          delete photos[roster[i]];
          roster.splice(i,1);
          peopleCountEl.value = roster.length;
          renderRosterInputs(); rebuildScoreInputs(); fillDatalist(); refreshAllCards(); renderPeopleStats(); renderAffinity();
        });

        const preview = personAvatarEl(name, 'lg');

        const nameWrap = document.createElement('div');
        nameWrap.style.display='flex'; nameWrap.style.alignItems='center'; nameWrap.style.gap='8px';
        nameWrap.appendChild(preview); nameWrap.appendChild(rowName);

        rosterEl.appendChild(nameWrap);
        rosterEl.appendChild(uploadBtn);
        rosterEl.appendChild(clearBtn);
        rosterEl.appendChild(removeBtn);

        const opt = document.createElement('option'); opt.value = name; datalistEl.appendChild(opt);
      });
    }

    function fillDatalist(){
      datalistEl.innerHTML = '';
      roster.forEach(n=>{ const o=document.createElement('option'); o.value=n; datalistEl.appendChild(o);});
    }

    function rebuildScoreInputs(){
      scoreInputsEl.innerHTML = '';
      const sub = (submitterEl.value || '').trim().toLowerCase();
      roster.forEach((name, idx)=>{
        const wrap = document.createElement('div');
        wrap.style.minWidth='200px'; wrap.style.flex='1 1 220px';

        const who = name || `Person ${idx+1}`;
        const isSubmitter = who.trim().toLowerCase() === sub && sub.length>0;

        const img = personAvatarEl(who);
        const txt = document.createElement('span'); txt.className='name'; txt.textContent = who;

        const tag = document.createElement('span');
        if(isSubmitter){ tag.className='markSubmitter'; tag.textContent='Submitter'; }

        const left = document.createElement('div');
        left.className='badge';
        left.appendChild(img);
        left.appendChild(txt);
        if(isSubmitter) left.appendChild(tag);

        const inp = document.createElement('input');
        inp.type='number'; inp.step='0.01'; inp.placeholder='score'; inp.dataset.person = who;
        if(isSubmitter){ inp.disabled = true; inp.title = 'Submitter cannot score their own song'; }

        const row = document.createElement('div');
        row.style.display='grid';
        row.style.gridTemplateColumns='1fr 90px';
        row.style.alignItems='center';
        row.style.gap='8px';

        const scoreWrap = document.createElement('div'); scoreWrap.className='score-cell';
        scoreWrap.appendChild(inp);

        row.appendChild(left);
        row.appendChild(scoreWrap);
        wrap.appendChild(row);

        scoreInputsEl.appendChild(wrap);
      });
    }

    submitterEl.addEventListener('input', rebuildScoreInputs);

    peopleCountEl.addEventListener('change', ()=>{
      const n = clamp(parseInt(peopleCountEl.value||'0',10),1,50);
      const diff = n - roster.length;
      if(diff>0){ for(let i=0;i<diff;i++){ roster.push(`Person ${roster.length+1}`);} }
      if(diff<0){
        const removed = roster.slice(n);
        removed.forEach(name => delete photos[name]);
        roster.splice(n);
      }
      renderRosterInputs(); rebuildScoreInputs(); fillDatalist(); refreshAllCards(); renderPeopleStats(); renderAffinity();
    });

    function computeAverage(scores){
      const vals = Object.values(scores).map(v=> typeof v==="number"? v : parseFloat(v)).filter(v=>!Number.isNaN(v));
      if(!vals.length) return 0;
      return vals.reduce((a,b)=>a+b,0)/vals.length;
    }

    function addSong(data){
      songs.push(data); rerenderCards(); renderPeopleStats(); renderAffinity();
    }

    function getExtrema(scores){
      const entries = Object.entries(scores).filter(([,v])=>v!=='' && v!=null && !Number.isNaN(parseFloat(v)));
      if(entries.length===0) return {maxNames:new Set(), minNames:new Set()};
      const nums = entries.map(([n,v])=>[n, parseFloat(v)]);
      const maxVal = Math.max(...nums.map(([,v])=>v));
      const minVal = Math.min(...nums.map(([,v])=>v));
      const maxNames = new Set(nums.filter(([,v])=>v===maxVal).map(([n])=>n));
      const minNames = new Set(nums.filter(([,v])=>v===minVal).map(([n])=>n));
      return {maxNames, minNames};
    }

    function clearEmptyState(){ const es = document.getElementById('emptyState'); if(es) es.remove(); }

    function sortByRanking(a,b){
      const diff = (b.avg) - (a.avg);
      if (Math.abs(diff) > EPS) return diff;
      return (tieBreakers.get(a.id) ?? 0) - (tieBreakers.get(b.id) ?? 0);
    }
    function shuffle(arr){ for (let i = arr.length - 1; i > 0; i--){ const j = Math.floor(Math.random() * (i + 1)); [arr[i], arr[j]] = [arr[j], arr[i]]; } return arr; }
    function assignRanks(){
      const sorted = [...songs].sort((a,b)=> (b.avg)-(a.avg));
      const eps = 1e-6, groups = []; let cur = [];
      for (const s of sorted){
        if (!cur.length || Math.abs(s.avg - cur[0].avg) <= eps) cur.push(s);
        else { groups.push(cur); cur = [s]; }
      }
      if (cur.length) groups.push(cur);
      const ordered = []; for (const g of groups){ shuffle(g); ordered.push(...g); }
      ranksMap = new Map(); ordered.forEach((s, idx)=>{ ranksMap.set(s.id, idx + 1); }); songs = ordered;
    }

    function placeText(n){
      const s = String(n);
      if(s.endsWith('11') || s.endsWith('12') || s.endsWith('13')) return `${n}th`;
      if(s.endsWith('1')) return `${n}st`;
      if(s.endsWith('2')) return `${n}nd`;
      if(s.endsWith('3')) return `${n}rd`;
      return `${n}th`;
    }
    function placementColor(rank){
      if(rank===1) return getComputedStyle(document.documentElement).getPropertyValue('--gold').trim() || '#f5c542';
      if(rank===2) return getComputedStyle(document.documentElement).getPropertyValue('--silver').trim() || '#c0c0c8';
      if(rank===3) return getComputedStyle(document.documentElement).getPropertyValue('--bronze').trim() || '#cd7f32';
      return getComputedStyle(document.documentElement).getPropertyValue('--ink').trim() || '#e8e8ea';
    }
	
	function chartGradient(color){
	  switch(color){
		case 'green':  return 'linear-gradient(180deg,#16a34a,#15803d)';
		case 'red':    return 'linear-gradient(180deg,#dc2626,#b91c1c)';
		case 'purple': return 'linear-gradient(180deg,#8b5cf6,#7c3aed)';
		case 'pink':   return 'linear-gradient(180deg,#ec4899,#db2777)';
		case 'gold':   return `linear-gradient(180deg,${getComputedStyle(document.documentElement).getPropertyValue('--gold').trim()||'#f5c542'},#d4a72c)`;
		case 'gray':   return 'linear-gradient(180deg,#6b7280,#4b5563)';
		default:       return 'linear-gradient(180deg,#2563eb,#1d4ed8)'; // blue
	  }
	}

    function rerenderCards(){
      cardsEl.innerHTML = ''; clearEmptyState();
      sortByEl.value = 'avg_desc';
      refreshTieBreakers(); songs.sort(sortByRanking); assignRanks();
      songs.forEach(song=> cardsEl.appendChild(renderCard(song)));
      document.querySelectorAll('.title, .artist, .hero .rank, .hero .avgnum').forEach(el=>{ shrinkToFit(el); resizeObserver.observe(el); });
    }

    function refreshAllCards(){
      refreshTieBreakers(); songs.sort(sortByRanking); assignRanks();
      document.querySelectorAll('.card').forEach(card=>{
        const id = card.dataset.id; const song = songs.find(s=>s.id===id);
        if(song){ card.replaceWith(renderCard(song)); }
      });
      document.querySelectorAll('.title, .artist, .hero .rank, .hero .avgnum').forEach(el=>{ shrinkToFit(el); resizeObserver.observe(el); });
    }

    /* ---------- Poster render helpers ---------- */
    function buildScoresList(names, song, extraClass=''){
      const {maxNames, minNames} = getExtrema(song.scores);
      const wrap = document.createElement('div');
      wrap.className = `scores ${extraClass}`.trim();

      names.forEach(person=>{
        const rowL = document.createElement('div');
        const badge = document.createElement('div'); badge.className='badge';
        const img = personAvatarEl(person);
        const nameSpan = document.createElement('span'); nameSpan.className='name'; nameSpan.textContent = person;
        badge.appendChild(img); badge.appendChild(nameSpan);

        const isSubmitter = (person && song.submitter && person.trim().toLowerCase()===song.submitter.trim().toLowerCase());
        if(isSubmitter){
          const m=document.createElement('span'); m.className='markSubmitter'; m.title='Submitter'; m.textContent='Submitter';
          badge.appendChild(m);
        }
        rowL.appendChild(badge);

        const rowR = document.createElement('div'); rowR.className='score-cell';

        const isFav = !!(song.favorites && song.favorites[person]);
        if(isFav){ const star = document.createElement('span'); star.className = 'favStar'; star.textContent = '‚òÖ'; rowR.appendChild(star); }

        const sv = document.createElement('span'); sv.className='score';
        if(isSubmitter) sv.textContent = '‚Äî';
        else {
          const val = song.scores[person];
          sv.textContent = (val===undefined||val==='')? '‚Äî' : String(val);
          if(maxNames.has(person)) sv.classList.add('high');
          if(minNames.has(person)) sv.classList.add('low');
        }
        rowR.appendChild(sv);

        wrap.appendChild(rowL); wrap.appendChild(rowR);
      });

      return wrap;
    }

    function renderPosterSidebar(song, color, rank){
      const card = document.createElement('article');
      card.className = 'card poster-sidebar';
      card.dataset.id = song.id;
      card.dataset.rank = String(rank);

      const grid = document.createElement('div'); grid.className = 'poster-grid'; card.appendChild(grid);

      // Left transparent panel (full height)
      const panel = document.createElement('div');
      panel.className = 'panel';
      panel.style.gridColumn = '1';
      panel.style.gridRow = '1 / -1';
      grid.appendChild(panel);

      const t = document.createElement('div'); t.className='title'; t.textContent = song.title; t.style.color = color;
      const a = document.createElement('div'); a.className='artist'; a.textContent = song.artist; a.style.color = color;
      panel.appendChild(t); panel.appendChild(a);

      const chip = document.createElement('div'); chip.className='hero chips';
      const rankEl = document.createElement('div'); rankEl.className='rank'; rankEl.textContent = 'Ranking: ' + placeText(rank); rankEl.style.color = color;
      const avgEl = document.createElement('div'); avgEl.className='avgnum'; avgEl.textContent = 'Average: ' + (Number.isFinite(song.avg)? song.avg.toFixed(2) : '‚Äî'); avgEl.style.color = color;
      chip.appendChild(rankEl); chip.appendChild(avgEl);
      panel.appendChild(chip);

      const lbl = document.createElement('div'); lbl.className='posterScoresLabel'; lbl.textContent = 'Scores';
      panel.appendChild(lbl);
      panel.appendChild(buildScoresList(roster, song, 'rail-scores'));

      // Right column spacer (keeps 16:9 grid)
      const spacer = document.createElement('div'); spacer.style.gridColumn = '2'; spacer.style.gridRow = '1 / -1'; grid.appendChild(spacer);

      const actions = document.createElement('div'); actions.className='card-actions';
      const dl = document.createElement('button'); dl.textContent = 'Export PNG'; dl.type='button';
      dl.addEventListener('click', ()=> downloadCardPNG(card, `${rank} (${sanitizeFilename(song.title)}).png`) );
      const del = document.createElement('button'); del.textContent = 'Delete'; del.type='button';
      del.addEventListener('click', ()=>{ songs = songs.filter(s=>s.id!==song.id); rerenderCards(); if(!songs.length){ showEmpty(); } });
      actions.appendChild(dl); actions.appendChild(del);
      card.appendChild(actions);

      return card;
    }

    function renderPosterSplit(song, color, rank){
      const card = document.createElement('article');
      card.className = 'card poster-split';
      card.dataset.id = song.id;
      card.dataset.rank = String(rank);

      const grid = document.createElement('div'); grid.className = 'poster-grid'; card.appendChild(grid);

      const half = Math.ceil(roster.length / 2);
      const leftNames = roster.slice(0, half);
      const rightNames = roster.slice(half);

      // LEFT RAIL (span all rows)
      const leftRail = document.createElement('div');
      leftRail.className='panel';
      leftRail.style.gridColumn = '1';
      leftRail.style.gridRow = '1 / -1';
      leftRail.appendChild((()=>{ const lbl=document.createElement('div'); lbl.className='posterScoresLabel'; lbl.textContent='Scores'; return lbl;})());
      leftRail.appendChild(buildScoresList(leftNames, song, 'rail-scores'));
      grid.appendChild(leftRail);

      // TOP CENTER CHIP (center column only)
      const top = document.createElement('div'); top.className='top-chip';
      const r = document.createElement('div'); r.className='rank'; r.textContent = 'Ranking'; r.style.color = color;
      const rnum = document.createElement('div'); rnum.className='rank'; rnum.textContent = placeText(rank); rnum.style.color = color; rnum.style.fontWeight='800';
      const a = document.createElement('div'); a.className='avgnum'; a.textContent = 'Average'; a.style.color = color;
      const anum = document.createElement('div'); anum.className='avgnum'; anum.textContent = Number.isFinite(song.avg)? song.avg.toFixed(2) : '‚Äî'; anum.style.color = color; anum.style.fontWeight='800';
      top.appendChild(r); top.appendChild(rnum); top.appendChild(a); top.appendChild(anum);
      top.style.gridColumn = '2'; top.style.gridRow = '1'; top.style.justifySelf='center'; top.style.alignSelf='start';
      grid.appendChild(top);

      // RIGHT RAIL (span all rows)
      const rightRail = document.createElement('div');
      rightRail.className='panel';
      rightRail.style.gridColumn = '3';
      rightRail.style.gridRow = '1 / -1';
      rightRail.appendChild((()=>{ const lbl=document.createElement('div'); lbl.className='posterScoresLabel'; lbl.textContent='Scores'; return lbl;})());
      rightRail.appendChild(buildScoresList(rightNames, song, 'rail-scores'));
      grid.appendChild(rightRail);

      // FOOTER (bottom, center column only)
      const footer = document.createElement('div'); footer.className='footer';
      const ft = document.createElement('div'); ft.className='title'; ft.textContent = song.title; ft.style.color = color;
      const fa = document.createElement('div'); fa.className='artist'; fa.textContent = song.artist; fa.style.color = color;
      footer.appendChild(ft); footer.appendChild(fa);
      footer.style.gridColumn = '2'; footer.style.gridRow = '3'; footer.style.justifySelf='center';
      grid.appendChild(footer);

      const actions = document.createElement('div'); actions.className='card-actions';
      const dl = document.createElement('button'); dl.textContent = 'Export PNG'; dl.type='button';
      dl.addEventListener('click', ()=> downloadCardPNG(card, `${rank} (${sanitizeFilename(song.title)}).png`) );
      const del = document.createElement('button'); del.textContent = 'Delete'; del.type='button';
      del.addEventListener('click', ()=>{ songs = songs.filter(s=>s.id!==song.id); rerenderCards(); if(!songs.length){ showEmpty(); } });
      actions.appendChild(dl); actions.appendChild(del);
      card.appendChild(actions);

      return card;
    }

    function renderCard(song){
      const rank = ranksMap.get(song.id) ?? 0;
      const color = placementColor(rank);
      const style = layoutStyleEl.value;

      if(style === 'poster-sidebar') return renderPosterSidebar(song, color, rank);
      if(style === 'poster-split')   return renderPosterSplit(song, color, rank);

      /* standard card */
      const {maxNames, minNames} = getExtrema(song.scores);

      const card = document.createElement('article');
      card.className = 'card';
      card.dataset.id = song.id;
      card.dataset.rank = String(rank);

      card.classList.toggle('compact', style==='compact');
      card.classList.toggle('borderless', style==='borderless');

      const title = document.createElement('div'); title.className='title'; title.textContent = song.title; title.style.color = color;
      const artist = document.createElement('div'); artist.className='artist'; artist.textContent = song.artist; artist.style.color = color;
      card.appendChild(title); card.appendChild(artist);

      const hero = document.createElement('div'); hero.className='hero';
      const rankEl = document.createElement('div'); rankEl.className='rank'; rankEl.textContent = placeText(rank); rankEl.style.color = color;
      const avgEl = document.createElement('div'); avgEl.className='avgnum'; avgEl.textContent = Number.isFinite(song.avg)? song.avg.toFixed(2) : '‚Äî'; avgEl.style.color = color;
      hero.appendChild(rankEl); hero.appendChild(avgEl);
      card.appendChild(hero);

      const scoresWrap = document.createElement('div'); scoresWrap.className='scores';
      roster.forEach(person=>{
        const rowL = document.createElement('div');
        const badge = document.createElement('div'); badge.className='badge';
        const img = personAvatarEl(person);
        const nameSpan = document.createElement('span'); nameSpan.className='name'; nameSpan.textContent = person;
        badge.appendChild(img); badge.appendChild(nameSpan);

        const isSubmitter = (person && song.submitter && person.trim().toLowerCase()===song.submitter.trim().toLowerCase());
        if(isSubmitter){ const m=document.createElement('span'); m.className='markSubmitter'; m.title='Submitter'; m.textContent='Submitter'; badge.appendChild(m); }
        rowL.appendChild(badge);

        const rowR = document.createElement('div'); rowR.className='score-cell';
        const isFav = !!(song.favorites && song.favorites[person]);
        if(isFav){ const star=document.createElement('span'); star.className='favStar'; star.textContent='‚òÖ'; rowR.appendChild(star); }
        const sv = document.createElement('span'); sv.className='score';
        const isSubmitter2 = (person && song.submitter && person.trim().toLowerCase()===song.submitter.trim().toLowerCase());
        if(isSubmitter2) sv.textContent='‚Äî';
        else{
          const val = song.scores[person];
          sv.textContent = (val===undefined||val==='')? '‚Äî' : String(val);
          if(maxNames.has(person)) sv.classList.add('high');
          if(minNames.has(person)) sv.classList.add('low');
        }
        rowR.appendChild(sv);

        scoresWrap.appendChild(rowL); scoresWrap.appendChild(rowR);
      });
      card.appendChild(scoresWrap);

      const actions = document.createElement('div'); actions.className='card-actions';
      const dl = document.createElement('button'); dl.textContent = 'Export PNG'; dl.type='button';
      dl.addEventListener('click', ()=> downloadCardPNG(card, `${rank} (${sanitizeFilename(song.title)}).png`) );
      const del = document.createElement('button'); del.textContent = 'Delete'; del.type='button';
      del.addEventListener('click', ()=>{ songs = songs.filter(s=>s.id!==song.id); rerenderCards(); if(!songs.length){ showEmpty(); } });
      actions.appendChild(dl); actions.appendChild(del);
      card.appendChild(actions);

      return card;
    }

    function showEmpty(){ const div = document.createElement('div'); div.className='empty'; div.id='emptyState'; div.textContent='No songs yet ‚Äî add one above ‚ú®'; cardsEl.appendChild(div); }

    // Export helpers (transparent PNGs)
    async function downloadCardPNG(cardEl, filename){
      const actions = cardEl.querySelector('.card-actions');
      const prevDisplay = actions ? actions.style.display : '';
      if(actions) actions.style.display = 'none';

      const originalBG = cardEl.style.backgroundColor;
      const originalBorder = cardEl.style.borderColor;
      cardEl.style.backgroundColor = 'transparent';
      cardEl.style.borderColor = 'transparent';

      const canvas = await html2canvas(cardEl, {backgroundColor:null, scale:2});
      const url = canvas.toDataURL('image/png');
      const a = document.createElement('a'); a.href=url; a.download=filename; a.click();

      cardEl.style.backgroundColor = originalBG; cardEl.style.borderColor = originalBorder;
      if(actions) actions.style.display = prevDisplay;
    }

    exportAllBtn.addEventListener('click', async()=>{
      const cards = [...document.querySelectorAll('.card')];
      for(const c of cards){
        const title = c.querySelector('.title')?.textContent?.trim() || 'song';
        const rank = c.dataset.rank ? parseInt(c.dataset.rank,10) : 0;
        const fname = `${rank} (${sanitizeFilename(title)}).png`;
        await downloadCardPNG(c, fname);
      }
    });

    layoutStyleEl.addEventListener('change', ()=>{ rerenderCards(); renderPeopleStats(); renderAffinity(); });

    sortByEl.addEventListener('change', ()=>{
      if(sortByEl.value === 'avg_desc'){ rerenderCards(); }
      else{
        const val = sortByEl.value;
        refreshTieBreakers();
        const fn = (a,b)=>{
          let diff;
          if(val==='avg_asc') diff = (a.avg) - (b.avg);
          else if(val==='title_asc') diff = a.title.localeCompare(b.title, undefined, {sensitivity:'base'});
          else if(val==='artist_asc') diff = a.artist.localeCompare(b.artist, undefined, {sensitivity:'base'});
          else diff = (b.avg) - (a.avg);
          if (diff !== 0 && !Number.isNaN(diff)) return diff;
          return (tieBreakers.get(a.id) ?? 0) - (tieBreakers.get(b.id) ?? 0);
        };
        songs.sort(fn);
        assignRanks();
        cardsEl.innerHTML=''; clearEmptyState();
        songs.forEach(s=> cardsEl.appendChild(renderCard(s)));
        document.querySelectorAll('.title, .artist, .hero .rank, .hero .avgnum').forEach(el=>{ shrinkToFit(el); resizeObserver.observe(el); });
      }
      renderPeopleStats(); renderAffinity();
    });

    songForm.addEventListener('submit', (e)=>{
      e.preventDefault();
      const title = titleEl.value.trim();
      const artist = artistEl.value.trim();
      const submitter = submitterEl.value.trim();
      const avgOverride = parseFloat(document.getElementById('avgOverride').value);

      const scores = {};
      [...scoreInputsEl.querySelectorAll('input')].forEach(inp=>{
        const who = inp.dataset.person; const val = inp.value.trim();
        if(!inp.disabled && val!=='' && !Number.isNaN(parseFloat(val))) scores[who] = parseFloat(val);
      });

      const avg = Number.isFinite(avgOverride) ? avgOverride : computeAverage(scores);
      addSong({ id: uid(), title, artist, submitter, scores, favorites: {}, avg });
      songForm.reset(); rebuildScoreInputs();
    });

    document.getElementById('clearForm').addEventListener('click', ()=>{
      songForm.reset(); rebuildScoreInputs();
    });

    /* ===== Bulk import ===== */
    function autoDelimiter(sample){
      if(delimiterEl.value !== 'auto') return delimiterEl.value;
      const counts = [',','\t',';'].map(d=>({d, c:(sample.match(new RegExp(d==='\t'?'\\t':d,'g'))||[]).length}))
        .sort((a,b)=>b.c-a.c);
      return (counts[0]?.c>0)? counts[0].d : '\t';
    }
    function parseCSV(text, delim){
      const out = []; let row = [], val = '', inQuotes = false;
      for(let i=0;i<text.length;i++){
        const ch = text[i];
        if(inQuotes){
          if(ch==='"' && text[i+1]==='"'){ val+='"'; i++; }
          else if(ch==='"'){ inQuotes = false; }
          else { val += ch; }
          continue;
        }
        if(ch==='"'){ inQuotes = true; continue; }
        if(ch==='\n'){ row.push(val); out.push(row); row=[]; val=''; continue; }
        if(ch==='\r'){ continue; }
        if(ch===delim){ row.push(val); val=''; continue; }
        val += ch;
      }
      row.push(val); out.push(row);
      if(out.length && out[out.length-1].every(c=>c==='')) out.pop();
      return out;
    }
    function headersToMap(headers){ const map = {}; headers.forEach((h,idx)=>{ map[lc(h)] = idx; }); return map; }
    function matchRosterHeader(h){
      const key = lc(h);
      let exact = roster.find(r => lc(r) === key);
      if(exact) return exact;
      const relax = key.replace(/[^a-z0-9]/g,'');
      exact = roster.find(r => lc(r).replace(/[^a-z0-9]/g,'') === relax);
      return exact || null;
    }
    function importRows(rows, hasHeader){
      if(!rows.length) return 0;
      let headers = [], dataRows = rows;

      if(hasHeader){ headers = rows[0]; dataRows = rows.slice(1); }
      else { headers = ['song','artist','submitter', ...roster]; }

      const hmap = headersToMap(headers);
      const titleIdx = hmap['song'] ?? hmap['title'] ?? 0;
      const artistIdx = hmap['artist'] ?? 1;
      const submitterIdx = hmap['submitter'] ?? 2;
      const averageIdx = hmap['average'];

      const scoreCols = []; const newScorers = [];
      headers.forEach((h,idx)=>{
        if(idx===titleIdx || idx===artistIdx || idx===submitterIdx || idx===averageIdx) return;
        const headerName = norm(h);
        if(!headerName || RESERVED_HEADERS.has(lc(headerName))) return;
        const who = matchRosterHeader(headerName);
        if(who){ scoreCols.push({idx, who}); }
        else { newScorers.push(headerName); scoreCols.push({idx, who: headerName}); }
      });

      if(newScorers.length){
        newScorers.forEach(n=>{ if(!roster.includes(n)) roster.push(n); });
        peopleCountEl.value = roster.length;
        renderRosterInputs(); rebuildScoreInputs(); fillDatalist();
      }

      let added = 0;
      dataRows.forEach(r=>{
        const title = norm(r[titleIdx]); const artist = norm(r[artistIdx]); const submitter = norm(r[submitterIdx]);
        if(!title) return;
        const scores = {}; const favorites = {};
        scoreCols.forEach(sc=>{
          const raw = norm(r[sc.idx]);
          if(raw==='' || isBlankScore(raw)) return;
          const { num, favorite } = parseScoreCell(raw);
          if(Number.isFinite(num)) { scores[sc.who] = num; if(favorite) favorites[sc.who] = true; }
        });
        let avg = computeAverage(scores);
        if(averageIdx!==undefined){
          const rawAvg = parseFloat(r[averageIdx]); if(Number.isFinite(rawAvg)) avg = rawAvg;
        }
        addSong({ id: uid(), title, artist, submitter, scores, favorites, avg });
        added++;
      });
      return added;
    }

    openBulkBtn.addEventListener('click', ()=>{
      bulkText.value = ''; hasHeaderEl.value = 'yes'; delimiterEl.value = 'auto'; bulkDialog.showModal();
    });
    cancelBulkBtn.addEventListener('click', ()=> bulkDialog.close());

    bulkForm.addEventListener('submit', (e)=>{
      e.preventDefault();
      const text = bulkText.value.trim();
      if(!text){ bulkDialog.close(); return; }
      const delim = autoDelimiter(text);
      const rows = parseCSV(text.replace(/\r\n?/g,'\n'), delim);
      const added = importRows(rows, hasHeaderEl.value==='yes');
      bulkDialog.close();
      if(added===0) alert('No rows imported. Check your headers: song, artist, submitter, and columns named after roster members. You can add * after a score to mark it as a favorite.');
    });

    /* Save a self-contained HTML snapshot */
    function buildSnapshotHTML(){
      const snapshot = { roster, photos, songs, layout: layoutStyleEl.value, sortBy: sortByEl.value };
      const injector =
`<script id="snapshot-applier">
  (function(){
    try{
      var snap = ${JSON.stringify(snapshot)};
      window.addEventListener('DOMContentLoaded', function(){
        try { roster = snap.roster || []; } catch(e){}
        try { photos = snap.photos || {}; } catch(e){}
        try { songs = snap.songs || []; } catch(e){}
        try { document.getElementById('layoutStyle').value = snap.layout || 'standard'; } catch(e){}
        try { document.getElementById('sortBy').value = snap.sortBy || 'avg_desc'; } catch(e){}
        try { document.getElementById('peopleCount').value = roster.length; } catch(e){}
        try { renderRosterInputs(); rebuildScoreInputs(); fillDatalist(); rerenderCards(); renderPeopleStats(); renderAffinity(); } catch(e){}
      });
    }catch(err){ console.error('Snapshot load failed', err); }
  })();
<\/script>`;
      const html = document.documentElement.outerHTML.replace('</body>', injector + '\n</body>');
      return html;
    }
    function downloadSnapshot(){
      const html = buildSnapshotHTML();
      const blob = new Blob([html], {type: 'text/html'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url; a.download = 'song-scoring-dashboard.html';
      document.body.appendChild(a); a.click(); a.remove();
      URL.revokeObjectURL(url);
    }
    downloadPageBtn.addEventListener('click', downloadSnapshot);

    /* ====== People Stats logic ====== */

    // Compute per-person stats:
    // - avgGiven: average of scores they gave (excluding songs they submitted)
    // - greensGiven: count of times they were the max scorer on a song
    // - redsGiven: count of times they were the min scorer on a song
    // - submitAvg: average received for their submitted songs (song.avg)
    // - submitRankAvg: average rank (1 = best) of their submitted songs
	// Avg (given)  = average of scores a person gave to others (never their own songs)
	// Avg (received) = average of ALL individual scores others gave to this person's submissions
	// Favorited = total number of favorite marks their submissions received (counts multiples)
	// Greens/Reds (given) = times they were the highest/lowest voter on any song
	function computePeopleStats(){
	  const base = {};
	  roster.forEach(name=>{
		base[name] = {
		  name,
		  givenVals: [],
		  receivedVals: [],
		  favMarksReceived: 0,
		  greensGiven: 0,
		  redsGiven: 0
		};
	  });

	  songs.forEach(song=>{
		const sub = (song.submitter||'').trim();

		// For submitter: collect received votes + favorite marks
		if(sub && base[sub]){
		  Object.entries(song.scores || {}).forEach(([voter,val])=>{
			const num = Number(val);
			if(Number.isFinite(num) && lc(voter) !== lc(sub)){
			  base[sub].receivedVals.push(num);
			}
		  });
		  const favs = song.favorites || {};
		  Object.entries(favs).forEach(([voter,flag])=>{
			if(flag && lc(voter) !== lc(sub)) base[sub].favMarksReceived += 1;
		  });
		}

		// For voters: values they gave + green/red counts
		const {maxNames, minNames} = getExtrema(song.scores || {});
		roster.forEach(person=>{
		  const isSubmitter = sub && lc(person) === lc(sub);
		  const val = Number(song.scores?.[person]);
		  if(!isSubmitter && Number.isFinite(val)){
			base[person].givenVals.push(val);
		  }
		});
		maxNames.forEach(n=>{ if(base[n]) base[n].greensGiven += 1; });
		minNames.forEach(n=>{ if(base[n]) base[n].redsGiven += 1; });
	  });

	  const avg = arr => arr.length ? arr.reduce((a,b)=>a+b,0)/arr.length : NaN;

	  return Object.values(base).map(p=>({
		name: p.name,
		avgGiven: avg(p.givenVals),
		avgReceived: avg(p.receivedVals),
		favorited: p.favMarksReceived,   // <-- total favorites received
		greensGiven: p.greensGiven,
		redsGiven: p.redsGiven
	  }));
	}


	function renderPeopleStats(){
	  const stats = computePeopleStats();

	  // Rank by Avg (received)
	  const ranked = [...stats].sort((a,b)=>{
		const A = Number.isFinite(a.avgReceived) ? a.avgReceived : -Infinity;
		const B = Number.isFinite(b.avgReceived) ? b.avgReceived : -Infinity;
		return B - A;
	  });

	  // For coloring Avg(received) top/bottom & Favorited gold
	  const recvVals = ranked.map(r => Number.isFinite(r.avgReceived) ? r.avgReceived : null).filter(v=>v!=null);
	  const globalMaxRecv = recvVals.length ? Math.max(...recvVals) : NaN;
	  const globalMinRecv = recvVals.length ? Math.min(...recvVals) : NaN;
	  const favVals = ranked.map(r => r.favorited || 0);
	  const globalMaxFav = favVals.length ? Math.max(...favVals) : 0;
	  
	// For coloring Avg (given)
	const givenVals = ranked.map(r => Number.isFinite(r.avgGiven) ? r.avgGiven : null).filter(v=>v!=null);
	const globalMaxGiven = givenVals.length ? Math.max(...givenVals) : NaN;
	const globalMinGiven = givenVals.length ? Math.min(...givenVals) : NaN;
	
	// Extremes for Greens/Reds counts
	const greensVals = ranked.map(r => r.greensGiven ?? 0);
	const redsVals   = ranked.map(r => r.redsGiven ?? 0);
	const maxGreens = greensVals.length ? Math.max(...greensVals) : 0;
	const minGreens = greensVals.length ? Math.min(...greensVals) : 0;
	const maxReds   = redsVals.length ? Math.max(...redsVals)   : 0;
	const minReds   = redsVals.length ? Math.min(...redsVals)   : 0;

	  // --- Chart (bars show Avg Received) ---
	  statsChartEl.innerHTML = '';
	  const maxVal = 10; // fixed scale 0..10

	  ranked.forEach((row, idx)=>{
		const rowEl = document.createElement('div');
		rowEl.className = 'chart-row';

		// Left label with avatar + name
		const left = document.createElement('div');
		left.className = 'chart-name';
		left.style.display = 'flex';
		left.style.alignItems = 'center';
		left.style.gap = '6px';
		const img = personAvatarEl(row.name); img.style.width='18px'; img.style.height='18px';
		const label = document.createElement('span'); label.textContent = `${idx+1}. ${row.name}`;
		left.appendChild(img); left.appendChild(label);
		rowEl.appendChild(left);

		// Bar (color selectable)
		const wrap = document.createElement('div');
		wrap.className = 'chart-bar-wrap';

		const bar = document.createElement('div');
		bar.className = 'chart-bar';
		bar.style.background = chartGradient(statsColor);

		const ratio = Number.isFinite(row.avgReceived) ? Math.max(0, Math.min(1, row.avgReceived / maxVal)) : 0;
		bar.style.width = (ratio * 100) + '%';

		const val = document.createElement('div');
		val.className = 'chart-val';
		val.textContent = Number.isFinite(row.avgReceived) ? row.avgReceived.toFixed(2) : '‚Äî';

		wrap.appendChild(bar);
		wrap.appendChild(val);
		rowEl.appendChild(wrap);
		statsChartEl.appendChild(rowEl);
	  });

	  // --- Table ---
	  statsTableEl.innerHTML = '';
	  const table = document.createElement('table');
	  const thead = document.createElement('thead');
	  thead.innerHTML = `
		<tr>
		  <th>Rank</th>
		  <th>Person</th>
		  <th title="Average score others gave to their submissions">Avg (received)</th>
		  <th title="Average score they gave to others">Avg (given)</th>
		  <th title="Total favorites their submissions received">Favorited ‚òÖ</th>
		  <th>Greens</th>
		  <th>Reds</th>
		</tr>`;
	  table.appendChild(thead);

	  const tbody = document.createElement('tbody');
	  ranked.forEach((r, i)=>{
		const tr = document.createElement('tr');

		const rankCell = document.createElement('td'); rankCell.innerHTML = `<span class="rank-badge">${i+1}</span>`;

		// Name cell with avatar
		const nm = document.createElement('td');
		nm.style.display = 'flex'; nm.style.alignItems = 'center'; nm.style.gap = '8px';
		const nmImg = personAvatarEl(r.name); nmImg.style.width='22px'; nmImg.style.height='22px';
		const nmTxt = document.createElement('span'); nmTxt.textContent = r.name;
		nm.appendChild(nmImg); nm.appendChild(nmTxt);

		const recv = document.createElement('td'); recv.className='pill';
		if(Number.isFinite(r.avgReceived)){
		  recv.textContent = r.avgReceived.toFixed(2);
		  if(r.avgReceived === globalMaxRecv) recv.classList.add('green');
		  if(r.avgReceived === globalMinRecv) recv.classList.add('red');
		} else {
		  recv.textContent = '‚Äî';
		}

		const given = document.createElement('td');
		given.className = 'pill';
		if (Number.isFinite(r.avgGiven)) {
		  given.textContent = r.avgGiven.toFixed(2);
		  // color by Avg (given): green = highest, red = lowest (ties color multiple rows)
		  if (r.avgGiven === globalMaxGiven) given.classList.add('green');
		  if (r.avgGiven === globalMinGiven) given.classList.add('red');
		} else {
		  given.textContent = '‚Äî';
		}


		const fav = document.createElement('td'); fav.className='pill'; fav.textContent = r.favorited || 0;
		if((r.favorited||0) === globalMaxFav && globalMaxFav > 0) fav.classList.add('gold');

		// Greens count (color only for extremes)
		const greens = document.createElement('td');
		greens.className = 'pill';
		const g = r.greensGiven ?? 0;
		greens.textContent = g;
		if (greensVals.length && maxGreens !== minGreens) {
		  if (g === maxGreens) greens.classList.add('green'); // highest ‚Üí green
		  if (g === minGreens) greens.classList.add('red');   // lowest  ‚Üí red
		}

		// Reds count (semantic: highest ‚Üí red, lowest ‚Üí green)
		const reds = document.createElement('td');
		reds.className = 'pill';
		const rd = r.redsGiven ?? 0;
		reds.textContent = rd;
		if (redsVals.length && maxReds !== minReds) {
		  if (rd === maxReds) reds.classList.add('red');     // highest ‚Üí red
		  if (rd === minReds) reds.classList.add('green');   // lowest  ‚Üí green
		}


		tr.append(rankCell,nm,recv,given,fav,greens,reds);
		tbody.appendChild(tr);
	  });
	  table.appendChild(tbody);
	  statsTableEl.appendChild(table);
	}



	// Build voter->submitter average matrix
	function computeAffinity(){
	  const submitterSet = new Set();
	  songs.forEach(s=>{ const sub=(s.submitter||'').trim(); if(sub) submitterSet.add(sub); });
	  const submitters = [...submitterSet];

	  // matrix[voter][submitter] = {sum,count}
	  const matrix = {};
	  roster.forEach(v=>{ matrix[v] = {}; submitters.forEach(s=> matrix[v][s] = {sum:0,count:0}); });

	  songs.forEach(song=>{
		const sub = (song.submitter||'').trim();
		if(!sub) return;
		Object.entries(song.scores||{}).forEach(([voter, val])=>{
		  const num = Number(val);
		  if(Number.isFinite(num) && lc(voter) !== lc(sub)){
			matrix[voter] ??= {};
			matrix[voter][sub] ??= {sum:0,count:0};
			matrix[voter][sub].sum += num;
			matrix[voter][sub].count += 1;
		  }
		});
	  });

	  const rows = roster.map(voter=>{
		const values = {};
		submitters.forEach(sub=>{
		  const cell = matrix[voter]?.[sub];
		  values[sub] = (cell && cell.count) ? (cell.sum / cell.count) : NaN;
		});
		return { voter, values };
	  });

	  const maxVal = Math.max(1, ...rows.flatMap(r=> submitters.map(s=> Number.isFinite(r.values[s]) ? r.values[s] : 0)));
	  return { submitters, rows, maxVal };
	}

	function renderAffinity(){
	  const { submitters, rows } = computeAffinity();
	  affinityTableEl.innerHTML = '';

	  const table = document.createElement('table');

	  const thead = document.createElement('thead');
	  thead.innerHTML =
		'<tr><th>Voter ‚Üì / Submitter ‚Üí</th>' +
		submitters.map(s => '<th>' + s + '</th>').join('') +
		'</tr>';
	  table.appendChild(thead);

	  const tbody = document.createElement('tbody');
	  rows.forEach(r => {
		const tr = document.createElement('tr');
		const head = document.createElement('td');
		head.textContent = r.voter;
		tr.appendChild(head);

		const rowVals = submitters.map(s => r.values[s]).filter(v => Number.isFinite(v));
		const rowMax = rowVals.length ? Math.max(...rowVals) : NaN;
		const rowMin = rowVals.length ? Math.min(...rowVals) : NaN;

		submitters.forEach(sub => {
		  const val = r.values[sub];
		  const td = document.createElement('td');
		  const span = document.createElement('span');
		  span.className = 'aff-num';
		  if(Number.isFinite(val)){
			span.textContent = val.toFixed(2);
			if(val === rowMax) span.classList.add('best');
			if(val === rowMin) span.classList.add('worst');
		  } else {
			span.textContent = '‚Äî';
		  }
		  td.appendChild(span);
		  tr.appendChild(td);
		});

		tbody.appendChild(tr);
	  });

	  table.appendChild(tbody);
	  affinityTableEl.appendChild(table);
	}

	// Compute pairwise joint affinity among people who have submitted at least once.
	// joint = (A‚ÜíB + B‚ÜíA) / 2, only ranked if both directions exist.
	function computeJointAffinity(){
	  const { submitters, rows } = computeAffinity();
	  // voter -> { submitter: avg } lookup
	  const look = new Map(rows.map(r => [r.voter, r.values]));

	  const pairs = [];
	  for(let i=0; i<submitters.length; i++){
		for(let j=i+1; j<submitters.length; j++){
		  const A = submitters[i], B = submitters[j];
		  const aToB = look.get(A)?.[B];
		  const bToA = look.get(B)?.[A];
		  const aOK = Number.isFinite(aToB), bOK = Number.isFinite(bToA);
		  const joint = (aOK && bOK) ? (aToB + bToA)/2 : NaN;
		  pairs.push({ A, B, aToB, bToA, joint });
		}
	  }
	  return pairs;
	}

	function renderJointAffinity(){
	  const pairs = computeJointAffinity()
		.filter(p => Number.isFinite(p.joint))
		.sort((a,b) => b.joint - a.joint);

	  jointAffinityTableEl.innerHTML = '';
	  const table = document.createElement('table');

	  const thead = document.createElement('thead');
	  thead.innerHTML = `
		<tr>
		  <th>Rank</th>
		  <th>Pair</th>
		  <th title="Average A gave to B">A‚ÜíB</th>
		  <th title="Average B gave to A">B‚ÜíA</th>
		  <th title="(A‚ÜíB + B‚ÜíA)/2">Joint Avg</th>
		</tr>`;
	  table.appendChild(thead);

	  const tbody = document.createElement('tbody');
	  pairs.forEach((p, idx) => {
		const tr = document.createElement('tr');

		const rank = document.createElement('td'); rank.innerHTML = `<span class="rank-badge">${idx+1}</span>`;

		// Pair cell centered on the arrow; both sides centered within their halves
		const pair = document.createElement('td');
		const wrap = document.createElement('div');
		wrap.style.display = 'grid';
		wrap.style.gridTemplateColumns = '1fr auto 1fr';
		wrap.style.alignItems = 'center';
		wrap.style.columnGap = '10px';

		// Left (A) ‚Äî center group
		const left = document.createElement('div');
		left.style.display = 'flex';
		left.style.alignItems = 'center';
		left.style.justifyContent = 'center';
		left.style.gap = '6px';
		const aImg = personAvatarEl(p.A); aImg.style.width='22px'; aImg.style.height='22px';
		const aName = document.createElement('span'); aName.textContent = p.A;
		left.appendChild(aImg); left.appendChild(aName);

		// Middle arrow (exact center)
		const sep = document.createElement('span');
		sep.textContent = '‚Üî';
		sep.style.textAlign = 'center';

		// Right (B) ‚Äî center group; name then avatar (avatar on the right)
		const right = document.createElement('div');
		right.style.display = 'flex';
		right.style.alignItems = 'center';
		right.style.justifyContent = 'center';
		right.style.gap = '6px';
		const bName = document.createElement('span'); bName.textContent = p.B;
		const bImg = personAvatarEl(p.B); bImg.style.width='22px'; bImg.style.height='22px'; bImg.style.marginLeft = '2px';
		right.appendChild(bName); right.appendChild(bImg);

		wrap.appendChild(left);
		wrap.appendChild(sep);
		wrap.appendChild(right);
		pair.appendChild(wrap);

		const a2b = document.createElement('td'); a2b.className='pill'; a2b.textContent = Number.isFinite(p.aToB) ? p.aToB.toFixed(2) : '‚Äî';
		const b2a = document.createElement('td'); b2a.className='pill'; b2a.textContent = Number.isFinite(p.bToA) ? p.bToA.toFixed(2) : '‚Äî';
		const joint = document.createElement('td'); joint.className='pill'; joint.textContent = p.joint.toFixed(2);

		tr.append(rank, pair, a2b, b2a, joint);
		tbody.appendChild(tr);
	  });

	  table.appendChild(tbody);
	  jointAffinityTableEl.appendChild(table);
	}




	// Export chart/panel PNG
    async function exportElementPNG(el, filename){
	  if(!el) return;
	  const canvas = await html2canvas(el, {
		backgroundColor: null,
		scale: 2,
		useCORS: true,
		allowTaint: true
	  });
	  const url = canvas.toDataURL('image/png');
	  const a = document.createElement('a');
	  a.href = url;
	  a.download = filename;
	  document.body.appendChild(a);  // ensure click works on all browsers
	  a.click();
	  a.remove();
	}

    exportStatsChartBtn.addEventListener('click', ()=> exportElementPNG(statsChartEl, 'people-ranking-chart.png'));
    exportStatsPanelBtn.addEventListener('click', ()=> exportElementPNG(statsSectionEl, 'people-stats.png'));
	exportAffinityBtn?.addEventListener('click', ()=> exportElementPNG(affinitySectionEl, 'affinity.png'));
	
	if (exportJointAffinityBtn) {
	  exportJointAffinityBtn.addEventListener('click', () => {
		const section = document.getElementById('jointAffinitySection'); // fresh lookup
		exportElementPNG(section, 'joint-affinity.png');
	  });
	}
    // init
    renderRosterInputs();
    rebuildScoreInputs();
    fillDatalist();
    sortByEl.value = 'avg_desc';

    // Keep stats responsive to content changes
    const observer = new MutationObserver(() => { renderPeopleStats(); renderAffinity(); renderJointAffinity(); });
    observer.observe(cardsEl, {childList:true, subtree:true});

    // Initial render
    renderPeopleStats(); renderAffinity(); renderJointAffinity();
  </script>
</body>
</html>
